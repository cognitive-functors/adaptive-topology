# Базовые функторы категории Lin

## Введение

Данный документ описывает **систему базовых функторов**, через которые можно выразить любой функтор в категории **Lin** (дифференциальная линейная логика с зависимыми типами, MALL-связками и (ко)индуктивными типами).

**Основная гипотеза** *(Conjecture)*: Любой полиномиальный функтор F : **Lin** → **Lin** может быть построен из базовых функторов и функториальных комбинаторов. *(Полное доказательство требует формализации; ниже приведён набросок аргумента.)*

**Принцип наследования**: Функториальные комбинаторы (операции над функторами) наследуют обозначения и свойства из базовой категории **Lin**:
- Комбинатор ⊗ для функторов использует ⊗ из **Lin** поточечно
- Комбинаторы &, ⊕, ⅋ аналогично наследуют структуру из **Lin**
- Дифференциальный оператор ∂ наследует дифференциальную структуру из **Lin**
- Это создаёт единообразие между уровнем объектов и уровнем функторов

Таким образом, категория эндофункторов [**Lin**, **Lin**] отражает структуру базовой категории **Lin**, включая её моноидальную, биноидальную и **дифференциальную** структуру.

**Модальности**: Кроме базовых функторов, система позволяет определить **модальные функторы** (экспоненциальные, темпоральные, пространственные, деонтические, алетические, эпистемические, вероятностные, градуированные) через комбинацию (ко)индуктивных типов, MALL-связок и зависимых функторов. Модальности **не входят в базовую систему**, но естественным образом выражаются через неё.

## 1. Примитивные функторы

### 1.1 Тождественный функтор (Id)

```
Id : Lin → Lin
Id(A) = A
Id(f : A → B) = f : A → B
```

**Свойства**:
- Id ∘ F = F ∘ Id = F для любого функтора F
- Единица для вертикальной композиции функторов

**Применение**: Рекурсивная переменная в (ко)индуктивных типах.

### 1.2 Константные функторы (K_C)

Для каждого объекта C ∈ **Lin**:

```
K_C : Lin → Lin
K_C(A) = C
K_C(f : A → B) = id_C : C → C
```

**Свойства**:
- Игнорирует аргумент
- K_C ∘ F = K_C для любого F
- Базис для базовых случаев (ко)индуктивных типов

**Примеры**:
- K_1 — константный функтор для единицы (завершение списка)
- K_⊤ — константный функтор для top (завершение мультимножества)
- K_A — константный функтор для любого типа A

### 1.3 Диагональный функтор (Δ)

```
Δ : Lin → Lin × Lin
Δ(A) = (A, A)
Δ(f : A → B) = (f, f) : (A, A) → (B, B)
```

**Свойства**:
- Дублирует объект в пару
- Естественная трансформация для копирования

**Применение**: Используется для построения функторов, применяющих одинаковые операции к обоим аргументам (например, X ⊗ X).

**Замечание**: Проекции π₁ : A & B → A и π₂ : A & B → B существуют только для категорного произведения &, но не являются отдельными базовыми функторами — они встроены в структуру бифунктора &.

## 2. Функторы для MALL-связок

### 2.1 Тензорный функтор (⊗)

**Как бифунктор**:
```
(−) ⊗ (−) : Lin × Lin → Lin
(A, B) ↦ A ⊗ B
(f : A → A', g : B → B') ↦ f ⊗ g : A ⊗ B → A' ⊗ B'
```

**Частичное применение** (даёт семейство функторов):
```
A ⊗ (−) : Lin → Lin
(−) ⊗ B : Lin → Lin
```

**Свойства**:
- Строго ковариантен по обоим аргументам
- Симметричен: A ⊗ B ≅ B ⊗ A (через симметрию σ)
- Ассоциативен: (A ⊗ B) ⊗ C ≅ A ⊗ (B ⊗ C) (через ассоциатор α)

**Функториальные законы**:
```
id_A ⊗ id_B = id_{A⊗B}
(f ∘ f') ⊗ (g ∘ g') = (f ⊗ g) ∘ (f' ⊗ g')
```

### 2.2 Par-функтор (⅋)

```
(−) ⅋ (−) : Lin × Lin → Lin
(A, B) ↦ A ⅋ B
(f, g) ↦ f ⅋ g
```

**Свойства**:
- Дуален к ⊗ через линейное отрицание: (A ⊗ B)⊥ = A⊥ ⅋ B⊥
- Также ковариантен по обоим аргументам
- Симметричен и ассоциативен

### 2.3 Аддитивная конъюнкция (&)

```
(−) & (−) : Lin × Lin → Lin
(A, B) ↦ A & B
(f : A → A', g : B → B') ↦ ⟨f ∘ π₁, g ∘ π₂⟩ : A & B → A' & B'
```

**Свойства**:
- Категорное произведение
- Универсальное свойство через проекции π₁, π₂
- Ковариантен по обоим аргументам

**Функториальное действие на морфизмах**:
```
f & g : A & B → A' & B'
(f & g)(x) = ⟨f(π₁(x)), g(π₂(x))⟩
```

### 2.4 Аддитивная дизъюнкция (⊕)

```
(−) ⊕ (−) : Lin × Lin → Lin
(A, B) ↦ A ⊕ B
(f : A → A', g : B → B') ↦ [inl' ∘ f, inr' ∘ g] : A ⊕ B → A' ⊕ B'
```

**Свойства**:
- Категорное копроизведение
- Универсальное свойство через инъекции inl, inr
- Ковариантен по обоим аргументам

**Функториальное действие**:
```
f ⊕ g : A ⊕ B → A' ⊕ B'
(f ⊕ g)(inl(a)) = inl'(f(a))
(f ⊕ g)(inr(b)) = inr'(g(b))
```

## 3. Функторы для зависимых типов

### 3.1 Зависимая сумма (Σ⊗)

Для семейства типов B : A → Type:

```
Σ⊗_A(B) : Lin/A → Lin
Σ⊗_A(B) = Σ⊗(x:A).B(x)
```

**Функториальное действие**: Для морфизма σ : B → B' в Lin/A:
```
Σ⊗(σ) : Σ⊗(x:A).B(x) → Σ⊗(x:A).B'(x)
Σ⊗(σ)(a, b) = (a, σ_a(b))
```

**Свойство**: Левый сопряжённый к функтору замены базы (pullback).

### 3.2 Зависимое произведение par (Π⅋)

```
Π⅋_A(B) : Lin/A → Lin
Π⅋_A(B) = Π⅋(x:A).B(x)
```

**Функториальное действие**:
```
Π⅋(σ) : Π⅋(x:A).B(x) → Π⅋(x:A).B'(x)
Π⅋(σ)(f)(a) = σ_a(f(a))
```

### 3.3 Индексированное произведение (Π&)

```
Π&_I(A) : (I → Lin) → Lin
Π&(i:I).A(i)
```

**Функториальное действие**: Для естественной трансформации τ : A ⇒ B:
```
Π&(τ) : Π&(i:I).A(i) → Π&(i:I).B(i)
Π&(τ)(f)(i) = τ_i(f(i))
```

**Категорная интерпретация**: Предел диаграммы I → **Lin**.

### 3.4 Индексированное копроизведение (Σ⊕)

```
Σ⊕_I(A) : (I → Lin) → Lin
Σ⊕(i:I).A(i)
```

**Функториальное действие**:
```
Σ⊕(τ) : Σ⊕(i:I).A(i) → Σ⊕(i:I).B(i)
Σ⊕(τ)(i, a) = (i, τ_i(a))
```

**Категорная интерпретация**: Копредел диаграммы I → **Lin**.

## 4. Функторы неподвижных точек

### 4.1 Функтор начальной алгебры (μ)

Для эндофунктора F : **Lin** → **Lin**:

```
μ : [Lin → Lin] → Lin
μ(F) = μX.F(X)
```

**Не функтор в обычном смысле**, но оператор на эндофункторах.

**Действие на естественных трансформациях**: Для τ : F ⇒ G:
```
μ(τ) : μF → μG
μ(τ) = cata(fold_G ∘ G(μ(τ)) ∘ τ_{μF})
```

**Свойство**: Начальная F-алгебра с универсальным морфизмом (катаморфизм).

### 4.2 Функтор терминальной коалгебры (ν)

```
ν : [Lin → Lin] → Lin
ν(F) = νX.F(X)
```

**Действие на естественных трансформациях**: Для τ : F ⇒ G:
```
ν(τ) : νF → νG
ν(τ) = ana(τ_{νG} ∘ F(ν(τ)) ∘ unfold_F)
```

**Свойство**: Терминальная F-коалгебра с универсальным морфизмом (анаморфизм).

### 4.3 Размерные функторы (μ^α, ν^α)

Для каждого размера α:

```
μ^α : [Lin → Lin] → Lin
ν^α : [Lin → Lin] → Lin
```

Параметризованные версии μ и ν с ограничением размера.

## 5. Функториальные комбинаторы

Комбинаторы над функторами **наследуют обозначения** из базовой категории **Lin**.

### 5.1 Композиция функторов (∘)

```
(∘) : [Lin → Lin] × [Lin → Lin] → [Lin → Lin]
(G ∘ F)(A) = G(F(A))
(G ∘ F)(f) = G(F(f))
```

**Свойства**:
- Ассоциативна: (H ∘ G) ∘ F = H ∘ (G ∘ F)
- Единица: Id ∘ F = F ∘ Id = F

**Применение**: Построение сложных функторов из простых (вертикальная композиция).

### 5.2 Тензорное произведение функторов (⊗)

**Наследует обозначение из категории Lin**:

```
(⊗) : [Lin → Lin] × [Lin → Lin] → [Lin → Lin]
(F ⊗ G)(A) = F(A) ⊗ G(A)
(F ⊗ G)(f) = F(f) ⊗ G(f)
```

**Свойства**:
- Симметричен: F ⊗ G ≅ G ⊗ F (через σ)
- Ассоциативен: (F ⊗ G) ⊗ H ≅ F ⊗ (G ⊗ H) (через α)
- Единица: K_1 ⊗ F ≅ F ≅ F ⊗ K_1

**Применение**: Мультипликативная комбинация функторов. Результат содержит оба компонента независимо.

**Пример**:
```
(K_A ⊗ Id)(X) = A ⊗ X -- константа тензор с аргументом
(Id ⊗ Id)(X) = X ⊗ X -- квадратичный функтор
```

### 5.3 Par-произведение функторов (⅋)

**Наследует обозначение из категории Lin**:

```
(⅋) : [Lin → Lin] × [Lin → Lin] → [Lin → Lin]
(F ⅋ G)(A) = F(A) ⅋ G(A)
(F ⅋ G)(f) = F(f) ⅋ G(f)
```

**Свойства**:
- Дуален к ⊗ на уровне функторов
- Симметричен и ассоциативен
- Единица: K_⊥

**Применение**: Параллельная композиция функториальных эффектов.

### 5.4 Аддитивная конъюнкция функторов (&)

**Наследует обозначение из категории Lin**:

```
(&) : [Lin → Lin] × [Lin → Lin] → [Lin → Lin]
(F & G)(A) = F(A) & G(A)
(F & G)(f) = F(f) & G(f)
```

**Свойства**:
- Категорное произведение на функторах
- Проекции: τ₁ : F & G ⇒ F и τ₂ : F & G ⇒ G (естественные трансформации)
- Универсальное свойство: для σ₁ : H ⇒ F и σ₂ : H ⇒ G существует ⟨σ₁, σ₂⟩ : H ⇒ F & G

**Применение**: Недетерминированный выбор между функториальными эффектами.

**Пример**:
```
(K_A & Id)(X) = A & X -- выбор между константой и аргументом
(Id & Id)(X) = X & X -- выбор между двумя копиями
```

**Важно**: Здесь проекции π₁, π₂ существуют как естественные трансформации между функторами, а не как отдельные функторы.

### 5.5 Аддитивная дизъюнкция функторов (⊕)

**Наследует обозначение из категории Lin**:

```
(⊕) : [Lin → Lin] × [Lin → Lin] → [Lin → Lin]
(F ⊕ G)(A) = F(A) ⊕ G(A)
(F ⊕ G)(f) = F(f) ⊕ G(f)
```

**Свойства**:
- Категорное копроизведение на функторах
- Инъекции: ι₁ : F ⇒ F ⊕ G и ι₂ : G ⇒ F ⊕ G (естественные трансформации)
- Универсальное свойство: для σ₁ : F ⇒ H и σ₂ : G ⇒ H существует [σ₁, σ₂] : F ⊕ G ⇒ H

**Применение**: Детерминированный выбор варианта функториального эффекта.

**Пример**:
```
(K_1 ⊕ (K_A ⊗ Id))(X) = 1 ⊕ (A ⊗ X) -- функтор списка (без μ)
```

### 5.6 Функтор-комбинатор применения бифунктора (App)

Для бифунктора B и функтора F:

```
App(B, F) : Lin → Lin
App(B, F)(X) = B(F(X), F(X))
```

**Примеры**:
```
App(⊗, Id)(X) = X ⊗ X -- квадратичный функтор
App(&, K_A)(X) = A & A -- константное произведение
App(⊕, F)(X) = F(X) ⊕ F(X) -- дизъюнкция двух F
```

**Применение**: Построение функторов, применяющих бифунктор к результатам другого функтора.

### 5.7 Дифференциальный комбинатор (∂)

**Дифференцирование как функториальный комбинатор**:

```
∂ : [Lin → Lin] → [Lin → Lin]
```

Для любого функтора F производная ∂F — это функтор, описывающий "одноточечные контексты" в F.

#### Правила дифференцирования

**Базовые правила**:
```
∂(Id)(A) = 1 -- производная переменной
∂(K_C)(A) = 0 -- производная константы
```

**Взаимодействие с функториальными комбинаторами**:

1. **Тензорное произведение** (правило Лейбница):
```
∂(F ⊗ G)(A) = (∂F(A) ⊗ G(A)) ⊕ (F(A) ⊗ ∂G(A))
```

Интерпретация: Дырка либо в левой части, либо в правой.

2. **Композиция** (цепное правило):
```
∂(G ∘ F)(A) = ∂G(F(A)) ⊗ ∂F(A)
```

Интерпретация: Внешний контекст ⊗ внутренний контекст.

3. **Аддитивные комбинаторы**:
```
∂(F & G)(A) = ∂F(A) & ∂G(A) -- выбор производной
∂(F ⊕ G)(A) = ∂F(A) ⊕ ∂G(A) -- тегированная производная
```

4. **Par** (дуально к ⊗):
```
∂(F ⅋ G)(A) = (∂F(A) ⅋ G(A)) ⊕ (F(A) ⅋ ∂G(A))
```

#### Дифференцирование неподвижных точек

**Индуктивные типы**:
```
∂(μF)(A) = Σ⊗(context : μF(A)). ∂F(μF(A))
```

**Интерпретация**: Контекст — это элемент структуры с дыркой. Сумма по всем возможным позициям дырки.

**Пример** (список):
```
F(X) = 1 ⊕ (A ⊗ X)
∂F(X) = ∂(1) ⊕ ∂(A ⊗ X)
 = 0 ⊕ ((∂A ⊗ X) ⊕ (A ⊗ ∂X))
 = (0 ⊗ X) ⊕ (A ⊗ 1)
 = A -- дырка может быть только в позиции элемента

∂(List_A) = Σ⊗(context : List_A). A
 ≅ List_A ⊗ A -- пара: список до дырки и элемент после
```

Более точно:
```
∂(List_A) = Σ⊗(prefix : List_A, suffix : List_A). 1
 ≅ List_A ⊗ List_A -- контекст = префикс ⊗ суффикс
```

**Коиндуктивные типы**:
```
∂(νF)(A) = Σ⊗(n : ℕ). ∂F^n(νF(A))
```

**Интерпретация**: Конечный путь до дырки в потенциально бесконечной структуре.

#### Высшие производные

**n-я производная**:
```
∂^0(F) = F
∂^{n+1}(F) = ∂(∂^n(F))
```

**Семантика**: ∂^n(F)(A) описывает контексты с **n дырками** в структуре F(A).

**Свойство симметрии**:
```
∂^n(F)(A) — симметричный функтор от n дырок
```

#### Дифференциальное исчисление на функторах

**Оператор дифференцирования коммутирует с некоторыми операциями**:

1. **Линейность по ⊕**:
```
∂(F ⊕ G) = ∂F ⊕ ∂G
```

2. **Дистрибутивность**:
```
∂(F ⊗ (G ⊕ H)) = ∂(F ⊗ G) ⊕ ∂(F ⊗ H)
```

3. **Цепное правило сохраняется**:
```
∂(H ∘ G ∘ F) = ∂H(G(F)) ⊗ ∂G(F) ⊗ ∂F
```

#### Связь с модальностями

**Дифференцирование модальностей**:
```
∂(!A) = !A ⊗ A -- производная "of course"
∂(?A) = ?A ⊗ A -- производная "why not"
```

**Интерпретация**: 
- ∂(!) выделяет одно использование из многих
- ∂(?) выделяет один выбор из возможных

#### Ультрафинитизм и дифференцируемость

**Гарантия терминации**: Благодаря sized types и конечности всех типов:
- Дифференцирование всегда терминирует
- ∂(μF) корректно определено (конечная глубина)
- ∂(νF) корректно определено (ограниченные пути)

**Универсальность**: Все функторы в **Lin** дифференцируемы без дополнительных условий.

## 6. Полная система базовых функторов

### 6.1 Минимальный базис

**Утверждение** *(Proposition — proof sketch)*: Следующий набор функторов **порождает** все полиномиальные функторы на **Lin**:

1. **Id** — тождественный функтор
2. **K_C** — константные функторы (для каждого C)
3. **(−) ⊗ (−)** — тензорное произведение
4. **(−) & (−)** — аддитивная конъюнкция
5. **(−) ⊕ (−)** — аддитивная дизъюнкция
6. **Σ⊗, Π&, Σ⊕** — зависимые функторы
7. **μ, ν** — операторы неподвижных точек

**Комбинаторы**:
- Композиция (∘)
- Частичное применение бифункторов

### 6.2 Выразимость

**Любой полиномиальный функтор** F можно представить в виде:

```
F(X) = Σ⊕(i:I). C_i ⊗ X^{⊗n_i}
```

где:
- I — индексное множество (для вариантов)
- C_i — константные типы (параметры варианта)
- X^{⊗n_i} — тензорные степени аргумента

**Пример построения**:

Функтор списка:
```
List : Lin → Lin
List(A) = μX. 1 ⊕ (A ⊗ X)

Раскладка:
List = μ ∘ (K_1 + (λX. A ⊗ X))
 = μ ∘ (K_1 ⊕ (K_A ⊗ Id))
```

Функтор бинарного дерева:
```
Tree(A) = μX. A ⊕ (X ⊗ X)

Раскладка:
Tree = μ ∘ (K_A ⊕ (Id ⊗ Id))
```

### 6.3 Расширенный базис (с ⅋)

Если включить:
- **(−) ⅋ (−)** — par
- **Π⅋** — зависимое произведение par

То можем выразить функторы с параллельной композицией.

### 6.4 Дифференциальный базис

Для дифференциальной категории добавляется:
- **∂** — оператор дифференцирования функторов

**Lin** является дифференциальной категорией, и дифференцирование поднимается на уровень функторов.

#### Дифференциальный функтор

Для любого дифференцируемого функтора F существует дифференциальный функтор **∂F**:

```
∂ : [Lin → Lin] → [Lin → Lin]
∂F : Lin → Lin
```

**Тип производной**:
```
∂F(A) : Lin -- производная функтора F в точке A
```

**Интерпретация**: ∂F(A) описывает "контекст" с одной дыркой типа A внутри структуры F(A).

#### Правила дифференцирования функторов

**Примитивные функторы**:
```
∂(Id) = K_1 -- производная переменной — константа
∂(K_C) = K_0 -- производная константы — ноль
```

**MALL-комбинаторы** (правило Лейбница):
```
∂(F ⊗ G) = (∂F ⊗ G) ⊕ (F ⊗ ∂G) -- сумма частных производных
∂(F & G) = (∂F) & (∂G) -- произведение производных
∂(F ⊕ G) = (∂F) ⊕ (∂G) -- копроизведение производных
∂(F ⅋ G) = (∂F ⅋ G) ⊕ (F ⅋ ∂G) -- дуально к ⊗
```

**Композиция** (цепное правило):
```
∂(G ∘ F) = (∂G ∘ F) ⊗ ∂F -- производная композиции
```

**Неподвижные точки**:
```
∂(μF) = Σ⊗(c : μF). ∂F(μF) -- контекст внутри индуктивного типа
∂(νF) = Σ⊗(path : ℕ). ∂F^n(νF) -- конечные пути в коиндуктивном типе
```

Где F^n означает n-кратную композицию F.

**Зависимые типы**:
```
∂(Σ⊗_A(B)) = Σ⊗(a:A). (∂B(a) ⊕ (B(a) ⊗ ∂A))
∂(Π&_I(A)) = Π&(i:I). (∂A(i) & (∀j≠i. A(j)))
```

#### Ультрафинитизм и дифференцируемость

**Теорема**: В категории **Lin** с sized types все функторы дифференцируемы.

**Обоснование**:
1. Каждый тип имеет конечный размер (по умолчанию 100500^100500)
2. Все (ко)индуктивные типы имеют ограниченную глубину
3. Дифференцирование всегда терминирует
4. Производная существует для любой комбинации базовых функторов

**Следствие**: Не требуется специальных условий позитивности для дифференцируемости — ультрафинитизм гарантирует корректность.

## 7. Примеры построения функторов

### 7.1 Список (List)

```
List_A : Lin → Lin
List_A = μ ∘ F
 где F(X) = 1 ⊕ (A ⊗ X)
 F = K_1 ⊕ (K_A ⊗ Id)
```

**Разложение**:
- Константа K_1 (пустой список)
- Композиция K_A ⊗ Id (голова и хвост)
- Копроизведение ⊕ (варианты)
- Неподвижная точка μ (рекурсия)

### 7.2 Поток (Stream)

```
Stream_A : Lin → Lin
Stream_A = ν ∘ F
 где F(X) = A & X
 F = (K_A) & Id
```

**Разложение**:
- Константа K_A (голова)
- Тождество Id (хвост)
- Аддитивная конъюнкция & (оба одновременно)
- Неподвижная точка ν (коиндукция)

### 7.3 Зависимый вектор (Vec)

```
Vec : Type → Size → Type
Vec(A, n) = μ^n V. (n = 0) & 1 ⊕ Σ⊗(m:Size). (n = s(m)) & (A ⊗ V(m))
```

**Разложение**:
- Σ⊗ — зависимая сумма по предыдущему размеру
- & — конъюнкция с предикатом равенства
- ⊗ — элемент и рекурсивный хвост
- ⊕ — базовый случай или рекурсия
- μ^n — размерная неподвижная точка

### 7.4 Функтор розового дерева (Rose Tree)

```
Rose : Lin → Lin
Rose(A) = μX. A ⊗ (?(List(X)))
```

где ? — монада мультимножеств.

**Разложение**:
- K_A ⊗ (? ∘ List ∘ Id)
- Композиция функторов: List затем ?
- Тензор с константой
- Рекурсия через μ

### 7.5 Функтор с зависимостью

```
Σ-List : (A : Type) → (A → Type) → Type
Σ-List(A, B) = μX. 1 ⊕ Σ⊗(a:A). (B(a) ⊗ X)
```

**Разложение**:
- Σ⊗ — зависимая сумма
- K_1 — пустой случай
- ⊗ — элемент зависимого типа и хвост
- ⊕ — варианты
- μ — рекурсия

### 7.6 Примеры дифференцирования функторов

#### 7.6.1 Дифференцирование списка

**Исходный функтор**:
```
List_A = μF, где F(X) = 1 ⊕ (A ⊗ X)
```

**Шаг 1**: Дифференцируем тело F
```
∂F(X) = ∂(1 ⊕ (A ⊗ X))
 = ∂(1) ⊕ ∂(A ⊗ X) -- правило для ⊕
 = 0 ⊕ (∂A ⊗ X ⊕ A ⊗ ∂X) -- правило Лейбница
 = 0 ⊕ (0 ⊗ X ⊕ A ⊗ 1) -- ∂A = 0, ∂X = 1
 = A -- упрощение
```

**Шаг 2**: Применяем правило для μ
```
∂(List_A) = Σ⊗(context : List_A). ∂F(List_A)
 = Σ⊗(context : List_A). A
 ≅ List_A ⊗ A
```

**Интерпретация**: Производная списка — это список (позиция дырки) тензор с типом элемента.

**Альтернативная интерпретация** (два фрагмента):
```
∂(List_A) ≅ Σ⊗(prefix : List_A, suffix : List_A). 1
 ≅ List_A ⊗ List_A
```

Контекст разбивает список на префикс (до дырки) и суффикс (после дырки).

#### 7.6.2 Дифференцирование потока

**Исходный функтор**:
```
Stream_A = νF, где F(X) = A & X
```

**Шаг 1**: Дифференцируем тело
```
∂F(X) = ∂(A & X)
 = ∂A & ∂X -- правило для &
 = 0 & 1 -- упрощение
 ≅ 1
```

**Шаг 2**: Применяем правило для ν
```
∂(Stream_A) = Σ⊗(n : ℕ). ∂F^n(Stream_A)
 = Σ⊗(n : ℕ). 1
 ≅ ℕ
```

**Интерпретация**: Производная потока — это натуральное число (позиция в потоке, глубина до дырки).

#### 7.6.3 Дифференцирование бинарного дерева

**Исходный функтор**:
```
Tree_A = μF, где F(X) = A ⊕ (X ⊗ X)
```

**Шаг 1**: Дифференцируем тело
```
∂F(X) = ∂(A ⊕ (X ⊗ X))
 = ∂A ⊕ ∂(X ⊗ X) -- правило для ⊕
 = 0 ⊕ (∂X ⊗ X ⊕ X ⊗ ∂X) -- правило Лейбница
 = (1 ⊗ X) ⊕ (X ⊗ 1) -- упрощение
 = X ⊕ X
```

**Шаг 2**: Применяем правило для μ
```
∂(Tree_A) = Σ⊗(context : Tree_A). (Tree_A ⊕ Tree_A)
 ≅ Σ⊗(context : Tree_A, direction : Bool). Tree_A
 ≅ Tree_A ⊗ Bool ⊗ Tree_A
```

**Интерпретация**: Контекст в дереве — это дерево (путь к дырке), направление (левое/правое поддерево), и дерево (другая ветка).

#### 7.6.4 Дифференцирование произведения

**Правило Лейбница для функторов**:
```
∂(F ⊗ G)(A) = (∂F(A) ⊗ G(A)) ⊕ (F(A) ⊗ ∂G(A))
```

**Пример**: Пара списков
```
F(A) = List_A ⊗ List_A

∂F(A) = (∂(List_A) ⊗ List_A) ⊕ (List_A ⊗ ∂(List_A))
 = ((List_A ⊗ A) ⊗ List_A) ⊕ (List_A ⊗ (List_A ⊗ A))
 ≅ (List_A ⊗ List_A ⊗ A) ⊕ (List_A ⊗ List_A ⊗ A)
```

**Интерпретация**: Дырка либо в первом списке, либо во втором.

#### 7.6.5 Дифференцирование композиции

**Цепное правило**:
```
∂(G ∘ F)(A) = ∂G(F(A)) ⊗ ∂F(A)
```

**Пример**: Список списков
```
F(A) = List_(List_A)

Пусть List = μL, Inner = List_A
F = List ∘ Inner

∂F(A) = ∂(List)(Inner(A)) ⊗ ∂(Inner)(A)
 = (List_(Inner(A)) ⊗ Inner(A)) ⊗ (Inner(A) ⊗ A)
 ≅ List_(List_A) ⊗ List_A ⊗ List_A ⊗ A
```

**Интерпретация**: 
- Внешний контекст: позиция в списке списков
- Внутренний контекст: позиция во внутреннем списке
- Их композиция даёт полный путь к элементу

#### 7.6.6 Дифференцирование зависимой суммы

**Правило**:
```
∂(Σ⊗_A(B)) = Σ⊗(a:A). (∂B(a) ⊕ (B(a) ⊗ ∂A))
```

**Интерпретация**: Дырка либо в зависимой части B(a), либо в индексе a.

#### 7.6.7 Высшие производные

**Вторая производная списка**:
```
∂²(List_A) = ∂(∂(List_A))
 = ∂(List_A ⊗ A)
 = ∂(List_A) ⊗ A ⊕ List_A ⊗ ∂A
 = (List_A ⊗ A) ⊗ A ⊕ List_A ⊗ 0
 ≅ List_A ⊗ A ⊗ A
 ≅ List_A ⊗ (A & A)
```

**Интерпретация**: Контекст с двумя дырками в списке.

**n-я производная**:
```
∂^n(List_A) ≅ List_A ⊗ A^{⊗n}
```

Контекст с n дырками.

## 8. Функториальные законы и проверка корректности

### 8.1 Проверка функториальности

Для функтора F : **Lin** → **Lin** должны выполняться:

**Закон тождества**:
```
F(id_A) = id_{F(A)}
```

**Закон композиции**:
```
F(g ∘ f) = F(g) ∘ F(f)
```

### 8.2 Проверка для базовых функторов

**Id**:
- Id(id_A) = id_A = id_{Id(A)} 
- Id(g ∘ f) = g ∘ f = Id(g) ∘ Id(f) 

**K_C**:
- K_C(id_A) = id_C = id_{K_C(A)} 
- K_C(g ∘ f) = id_C = id_C ∘ id_C = K_C(g) ∘ K_C(f) 

**⊗**:
- (f ⊗ g)(id_A ⊗ id_B) = id_A ⊗ id_B = id_{A⊗B} 
- (f ⊗ g) ∘ (f' ⊗ g') = (f ∘ f') ⊗ (g ∘ g') 

### 8.3 Сохранение функториальности комбинаторами

**Композиция**: Если F и G функторы, то G ∘ F функтор.

**Доказательство**:
```
(G ∘ F)(id_A) = G(F(id_A)) = G(id_{F(A)}) = id_{G(F(A))} 
(G ∘ F)(g ∘ f) = G(F(g ∘ f)) = G(F(g) ∘ F(f)) = G(F(g)) ∘ G(F(f)) 
```

**Тензорное произведение**: Если F и G функторы, то F ⊗ G функтор.

**Доказательство**: Аналогично, используя функториальные законы для ⊗ в **Lin**.

**Копроизведение**: Если F и G функторы, то F ⊕ G функтор.

### 8.4 Дифференциальные законы

**Дифференцирование сохраняет функториальность**: Если F — функтор, то ∂F — функтор.

#### Базовые правила дифференцирования

**Правило константы**:
```
∂(K_C) = K_0
```

**Правило переменной**:
```
∂(Id) = K_1
```

**Проверка функториальности** для ∂(Id) = K_1:
```
K_1(id_A) = id_1 = id_{K_1(A)} 
K_1(g ∘ f) = id_1 = id_1 ∘ id_1 = K_1(g) ∘ K_1(f) 
```

#### Правило Лейбница

**Для тензорного произведения**:
```
∂(F ⊗ G) = (∂F ⊗ G) ⊕ (F ⊗ ∂G)
```

**Доказательство функториальности**:

Пусть F и G — функторы. Покажем, что ∂(F ⊗ G) — функтор.

*Закон тождества*:
```
∂(F ⊗ G)(id_A) = (∂F ⊗ G)(id_A) ⊕ (F ⊗ ∂G)(id_A)
 = (∂F(id_A) ⊗ G(id_A)) ⊕ (F(id_A) ⊗ ∂G(id_A))
 = (id_{∂F(A)} ⊗ id_{G(A)}) ⊕ (id_{F(A)} ⊗ id_{∂G(A)})
 = id_{∂F(A)⊗G(A)} ⊕ id_{F(A)⊗∂G(A)}
 = id_{(∂F⊗G)(A) ⊕ (F⊗∂G)(A)}
 = id_{∂(F⊗G)(A)} 
```

*Закон композиции*: Аналогично проверяется через дистрибутивность ⊕.

#### Цепное правило

**Для композиции функторов**:
```
∂(G ∘ F) = (∂G ∘ F) ⊗ ∂F
```

**Доказательство функториальности**:

*Закон тождества*:
```
∂(G ∘ F)(id_A) = (∂G ∘ F)(id_A) ⊗ ∂F(id_A)
 = ∂G(F(id_A)) ⊗ ∂F(id_A)
 = ∂G(id_{F(A)}) ⊗ id_{∂F(A)}
 = id_{∂G(F(A))} ⊗ id_{∂F(A)}
 = id_{∂G(F(A)) ⊗ ∂F(A)}
 = id_{∂(G∘F)(A)} 
```

*Закон композиции*: Следует из функториальности ⊗ и композиции.

#### Линейность дифференцирования

**По аддитивной дизъюнкции**:
```
∂(F ⊕ G) = ∂F ⊕ ∂G
```

**Доказательство**: ⊕ функториален поточечно, производная от вариантов — это вариант производных.

**По аддитивной конъюнкции**:
```
∂(F & G) = ∂F & ∂G
```

**Доказательство**: & функториален поточечно, производная выбора — это выбор производных.

#### Правила для неподвижных точек

**Индуктивные типы**:
```
∂(μF) = Σ⊗(context : μF). ∂F(μF)
```

**Свойство**: Функториальность следует из функториальности Σ⊗ и ∂F.

**Коиндуктивные типы**:
```
∂(νF) = Σ⊗(depth : ℕ). ∂F^depth(νF)
```

**Свойство**: Конечная сумма функторов функториальна.

#### Дифференциальные тождества

**Идемпотентность нуля**:
```
∂(K_0) = K_0
∂(0) = 0
```

**Производная суммы**:
```
∂(F ⊕ G ⊕ H) = ∂F ⊕ ∂G ⊕ ∂H
```

**Производная n-арного тензора**:
```
∂(F₁ ⊗ F₂ ⊗ ... ⊗ Fₙ) = ∑ᵢ (F₁ ⊗ ... ⊗ ∂Fᵢ ⊗ ... ⊗ Fₙ)
```

Обобщённое правило Лейбница.

**Производная степени**:
```
∂(X^{⊗n}) = n ⊙ X^{⊗(n-1)}
```

где ⊙ — мультипликативная константа (n раз ⊕).

#### Универсальность дифференцирования

**Теорема**: В категории **Lin** с sized types:
1. Каждый функтор F дифференцируем
2. ∂F — функтор
3. Дифференцирование сохраняет все функториальные свойства
4. Высшие производные ∂ⁿF корректно определены для всех n

**Следствие**: Категория функторов [**Lin**, **Lin**] является **дифференциальной категорией** с оператором ∂.

## 9. Категория эндофункторов [Lin, Lin]

### 9.1 Структура категории

**Объекты**: Эндофункторы F : **Lin** → **Lin**

**Морфизмы**: Естественные трансформации τ : F ⇒ G

**Композиция**: Вертикальная композиция естественных трансформаций

**Тождество**: Тождественная естественная трансформация id_F

### 9.2 Моноидальная структура

**Моноидальное произведение 1**: Композиция функторов (∘)
- Единица: Id
- Ассоциатор: α_{F,G,H} : (F ∘ G) ∘ H ≅ F ∘ (G ∘ H)

Это делает [**Lin**, **Lin**] моноидальной категорией.

**Моноидальное произведение 2**: Тензор функторов (⊗)
- (F ⊗ G)(A) = F(A) ⊗ G(A)
- Единица: K_1
- Наследует симметрию и ассоциативность от ⊗ в **Lin**

### 9.3 Биноидальная структура

**Категория функторов наследует биноидальную структуру** из **Lin**:

**Аддитивная конъюнкция функторов**: F & G
- (F & G)(A) = F(A) & G(A)
- Проекции: τ₁ : F & G ⇒ F, τ₂ : F & G ⇒ G (естественные трансформации)
- Универсальное свойство произведения

**Аддитивная дизъюнкция функторов**: F ⊕ G
- (F ⊕ G)(A) = F(A) ⊕ G(A)
- Инъекции: ι₁ : F ⇒ F ⊕ G, ι₂ : G ⇒ F ⊕ G
- Универсальное свойство копроизведения

**Дуальная моноидальная структура**: F ⅋ G
- (F ⅋ G)(A) = F(A) ⅋ G(A)
- Дуальна к F ⊗ G

### 9.4 Наследование структуры из Lin

**Принцип наследования**: Категория эндофункторов [**Lin**, **Lin**] наследует структуру из **Lin** поточечно (pointwise).

Для любой структуры в **Lin** (где ∈ {⊗, ⅋, &, ⊕}):
```
(F G)(A) := F(A) G(A) (применение поточечно)
(F G)(f) := F(f) G(f) (на морфизмах)
```

**Наследуемые свойства**:

1. **От моноидальной структуры** (⊗, 1):
 - F ⊗ G моноидален, если F и G моноидальны
 - K_1 — единица для ⊗ на функторах
 - Ассоциативность и симметрия сохраняются

2. **От биноидальной структуры** (&, ⊕):
 - F & G имеет проекции (естественные трансформации)
 - F ⊕ G имеет инъекции (естественные трансформации)
 - Универсальные свойства поднимаются на уровень функторов

3. **От дуальности** (⊗ ↔ ⅋):
 - (F ⊗ G)⊥ ≅ F⊥ ⅋ G⊥ (если определено отрицание на функторах)

4. **От дистрибутивности**:
 - F ⊗ (G ⊕ H) ≅ (F ⊗ G) ⊕ (F ⊗ H)
 - Сохраняется на уровне функторов

**Категорная интерпретация**: [**Lin**, **Lin**] с поточечными операциями образует:
- Моноидальную категорию (с ∘ и ⊗)
- Биноидальную категорию (с & и ⊕)
- *-автономную структуру (через ⅋)

Все ключевые свойства **Lin** "поднимаются" на категорию функторов.

### 9.5 Дифференциальная структура

**[Lin, Lin] является дифференциальной категорией**.

#### Оператор дифференцирования на функторах

```
∂ : [Lin → Lin] → [Lin → Lin]
```

**Свойства**:
1. ∂ — эндофунктор на категории функторов
2. ∂ сохраняет функториальность (если F функтор, то ∂F функтор)
3. ∂ взаимодействует с моноидальной и биноидальной структурой

#### Взаимодействие с моноидальной структурой

**Правило Лейбница для ⊗**:
```
∂(F ⊗ G) ≅ (∂F ⊗ G) ⊕ (F ⊗ ∂G)
```

Существует естественный изоморфизм (дистрибутор дифференцирования):
```
δ⊗ : ∂(F ⊗ G) ⇒ (∂F ⊗ G) ⊕ (F ⊗ ∂G)
```

**Правило для композиции (цепное правило)**:
```
∂(G ∘ F) ≅ (∂G ∘ F) ⊗ ∂F
```

Естественная трансформация:
```
chain : ∂(G ∘ F) ⇒ (∂G ∘ F) ⊗ ∂F
```

#### Взаимодействие с биноидальной структурой

**Линейность по ⊕**:
```
∂(F ⊕ G) ≅ ∂F ⊕ ∂G
```

Изоморфизм естественен: дифференцирование коммутирует с копроизведением.

**Дистрибутивность через &**:
```
∂(F & G) ≅ ∂F & ∂G
```

Изоморфизм естественен: дифференцирование коммутирует с произведением.

#### Дифференциальная категориальная структура

**Определение**: Дифференциальная категория — это категория K с:
1. Моноидальной структурой (⊗, I)
2. Функтором дифференцирования ∂ : K → K
3. Естественными трансформациями δ⊗, chain удовлетворяющими аксиомам

**Теорема**: [**Lin**, **Lin**] с оператором ∂ является дифференциальной категорией.

**Доказательство**: 
- ⊗ на функторах моноидален (унаследован из **Lin**)
- ∂ функториален (раздел 8.4)
- δ⊗ и chain естественны и удовлетворяют аксиомам дифференциальной категории

#### Универсальное свойство дифференцирования

Для любого функтора F производная ∂F удовлетворяет:
```
F(A ⊕ ε·B) ≅ F(A) ⊕ ε·(∂F(A) ⊗ B)
```

где ε — формальная "бесконечно малая" величина (ε² = 0).

**Интерпретация**: ∂F(A) — это "направленная производная" функтора F в точке A.

#### Операторные свойства ∂

**1. Идемпотентность на константе**:
```
∂(K_0) = K_0
∂²(K_C) = K_0 (для C ≠ 0)
```

**2. Коммутативность с естественными трансформациями**:

Если τ : F ⇒ G естественная трансформация, то:
```
∂τ : ∂F ⇒ ∂G
```
также естественная трансформация.

**3. Сохранение неподвижных точек**:

Для алгебры α : F(A) → A:
```
∂α : ∂F(A) ⊗ A → A
```

Производная алгебры — это "обновление" структуры.

#### Высшие производные и тензорные степени

**n-я производная функтора**:
```
∂ⁿF : Lin → Lin
∂⁰F = F
∂ⁿ⁺¹F = ∂(∂ⁿF)
```

**Свойство**: ∂ⁿF(A) описывает контексты с n дырками типа A.

**Симметрия**: 
```
∂ⁿF(A) ≅ ∂ⁿF(A) ⊗ Sym_n
```

где Sym_n — симметрическая группа порядка n (перестановки дырок).

#### Связь с производной по Гато

В **Lin** дифференцирование функторов соответствует **производной Гато**:
```
lim_{ε→0} [F(A ⊕ ε·B) ⊖ F(A)] / ε = ∂F(A) ⊗ B
```

где ⊖ — обратная операция к ⊕ (в линейной логике).

#### Практическое значение

**Для программирования**:
- ∂F описывает "контексты" или "застёжки-молнии" (zippers)
- ∂ⁿF описывает многоточечные курсоры
- Дифференцирование даёт эффективные структуры данных для навигации

**Для теории типов**:
- Производная типа — это тип его одноточечных контекстов
- Цепное правило соответствует композиции контекстов
- Высшие производные — многоточечные контексты

**Для категорной семантики**:
- [**Lin**, **Lin**] — дифференциальная категория
- Дифференцирование — универсальная операция на функторах
- Все конструкции дифференцируемы благодаря ультрафинитизму

## 10. Вычислительная интерпретация

### 10.1 Функторы как контейнеры

Функтор F можно интерпретировать как "контейнер" со структурой:
- **Формы** (shapes): Σ⊕(s:Shape). ...
- **Позиции** (positions): ... ⊗ X^{⊗n}

**Пример**: Функтор списка
- Формы: длины n ∈ ℕ
- Позиции: n позиций для элементов

### 10.2 Функторы как синтаксические деревья

F(X) описывает синтаксическое дерево с переменными типа X:
- Константы K_C — листья
- Связки ⊗, &, ⊕ — узлы
- Id — позиции переменных

### 10.3 Функторы в программировании

Соответствие с функциональным программированием:
- μF — индуктивный тип данных (data)
- νF — коиндуктивный тип данных (codata)
- F — сигнатура функтора (в Haskell: Functor, Bifunctor)
- Естественные трансформации — полиморфные функции

## 11. Модальные функторы

**Важное замечание**: Модальные функторы **не входят в базовую систему** функторов (разделы 1-8), но структура категории **Lin** и базовых функторов позволяет их естественным образом определить через (ко)индуктивные типы.

### 11.1 Экспоненциальные модальности

#### 11.1.1 Комонада "Of Course" (!)

**Определение как (ко)индуктивный функтор**:
```
! : Lin → Lin
!A = νX. 1 ⊕ (A & X)
```

**Построение через базовые функторы**:
```
! = ν ∘ F
где F(X) = 1 ⊕ (A & X)
 F = K_1 ⊕ ((K_A) & Id)
```

**Функториальность**:
```
!(f : A → B) : !A → !B
```

**Комонадная структура**:
- **counit (ε)**: ε : !A → A
 - Извлечение одного использования
 - Реализуется через проекцию A & X → A
 
- **comultiplication (δ)**: δ : !A → !!A
 - Дублирование ресурса
 - Реализуется через удвоение коиндуктивного потока
 
- **weakening (w)**: w : !A → 1
 - Отбрасывание неиспользованного ресурса
 
- **contraction (c)**: c : !A → !A ⊗ !A
 - Разделение ресурса

**Производная**:
```
∂(!A) ≅ !A ⊗ A
```

**Интерпретация**: !A — это потенциально бесконечный поток значений A, доступных для неограниченного использования.

#### 11.1.2 Монада "Why Not" (?)

**Определение как (ко)индуктивный функтор**:
```
? : Lin → Lin
?A = μX. ⊤ ⊕ (A ⊗ X)
```

**Построение через базовые функторы**:
```
? = μ ∘ F
где F(X) = ⊤ ⊕ (A ⊗ X)
 F = K_⊤ ⊕ ((K_A) ⊗ Id)
```

**Функториальность**:
```
?(f : A → B) : ?A → ?B
```

**Монадная структура**:
- **unit (η)**: η : A → ?A
 - Упаковка одного значения
 - Реализуется через inr ∘ (id_A ⊗ (inl ⊤))
 
- **multiplication (μ)**: μ : ??A → ?A
 - Сплющивание вложенных мультимножеств
 - Реализуется через катаморфизм
 
- **absorption (a)**: a : ⊤ → ?A
 - Пустое мультимножество
 
- **addition (+)**: + : ?A ⊗ ?A → ?A
 - Объединение мультимножеств

**Производная**:
```
∂(?A) ≅ ?A ⊗ A
```

**Интерпретация**: ?A — это конечное мультимножество (список с дублями) значений A.

#### 11.1.3 Функциональная дуальность ! ⊣ ?

**Сопряжение**:
```
Lin(!A, B) ≅ Lin(A, ?B)
```

**Естественные трансформации**:
- **Структурная симметрия**: ν ↔ μ, & ↔ ⊗, ⊕ ↔ ⊕
- **Функциональная дуальность**: комонада ↔ монада

**Примечание о линейной негации**: Точная категорная дуальность через (−)⊥ не достигается из-за различий в единицах (1 vs. ⊤) и природы MALL-связок.

### 11.2 Временные модальности

#### 11.2.1 Всегда в будущем (□)

**Определение**:
```
□ : Lin → Lin
□A = νX. A & X
```

**Построение**:
```
□ = ν ∘ ((K_A) & Id)
```

**Функториальность**: Очевидна из композиции базовых функторов.

**Интерпретация**: Коиндуктивный поток значений A в каждый момент времени.

**Правила**:
- **now**: π₁ : □A → A (текущее значение)
- **next**: π₂ : □A → □A (сдвиг на следующий момент)

**Производная**:
```
∂(□A) ≅ ℕ ⊗ A
```
Позиция в потоке и значение в этой позиции.

**С зависимыми типами**:
```
□_t : (Time → Type) → Type
□_t A = Π&(t':Time, t'≥t). A(t')
```
Используя Π& из раздела 3.

**Обогащение**: 
- □^d A — с длительностью интервала
- Σ⊗(t:Time). □_{≥t} A(t) — параметризация временем

#### 11.2.2 Когда-нибудь в будущем (◇)

**Определение**:
```
◇ : Lin → Lin
◇A = μX. A ⊕ X
```

**Построение**:
```
◇ = μ ∘ ((K_A) ⊕ Id)
```

**Интерпретация**: Индуктивный тип — либо A сейчас, либо A позже.

**Правила**:
- **now**: inl : A → ◇A
- **later**: inr : ◇A → ◇A

**Производная**:
```
∂(◇A) ≅ ℕ ⊗ A
```
Номер шага, на котором достигается A.

**Дуальность**: □ и ◇ функционально дуальны (ν ↔ μ, & ↔ ⊕).

**С зависимыми типами**:
```
◇_t A = Σ⊕(t':Time, t'≥t). A(t')
```

#### 11.2.3 LTL операторы

**Until (U)**:
```
U : Lin × Lin → Lin
(A U B) = μX. B ⊕ (A ⊗ X)
```

**Функториальное построение**:
```
U(A, B) = μ ∘ (K_B ⊕ ((K_A) ⊗ Id))
```

**Интерпретация**: A держится до тех пор, пока не случится B.

**Release (R)**:
```
R : Lin × Lin → Lin
(A R B) = νX. B & (A ⅋ X)
```

**Дуальность**: U и R дуальны (μ ↔ ν, ⊕ ↔ &, ⊗ ↔ ⅋).

**С зависимыми типами**:
```
U_≤n : Σ⊗(k:ℕ_{≤n}). ((A U_k B)) -- bounded until
```

**Производная Until**:
```
∂(A U B) ≅ Σ⊗(n:ℕ). (A^⊗n ⊗ B)
```
n шагов ожидания до B.

### 11.3 Пространственные модальности

#### 11.3.1 Везде (□_S)

**Определение**:
```
□_S : (Location → Type) → Type
□_S A = Π&(l:Location). A(l)
```

**Построение**: Через Π& (раздел 3.3).

**Функториальность**: Наследуется от Π&.

**Интерпретация**: Индексированное произведение по всем локациям.

**С зависимыми типами**:
```
□_r : Σ⊗(center:Location). Π&(l:Location, d(l,center)≤r). A(l)
```
В радиусе r от центра.

#### 11.3.2 Где-то (◇_S)

**Определение**:
```
◇_S : (Location → Type) → Type
◇_S A = Σ⊕(l:Location). A(l)
```

**Построение**: Через Σ⊕ (раздел 3.4).

**Интерпретация**: Индексированное копроизведение по локациям.

**Дуальность**: □_S и ◇_S дуальны (Π& ↔ Σ⊕).

**С зависимыми типами**:
```
◇_Region : Σ⊗(r:Region). (Σ⊕(l:r). A(l))
```
По регионам.

### 11.4 Деонтические модальности

#### 11.4.1 Обязательно (O)

**Определение**:
```
O : Lin → Lin
O A = νX. A & (X ⊕ Violation)
```

**Построение**:
```
O = ν ∘ ((K_A) & (Id ⊕ K_Violation))
```

**Интерпретация**: Коиндуктивная последовательность проверок обязательства.

**Правила**:
- **current**: π₁ : O A → A (текущее выполнение)
- **continue**: π₂ : O A → O A ⊕ Violation (продолжение или нарушение)

**С зависимыми типами**:
```
O_c : Σ⊗(c:Context). (A(c) & Obligation(c))
```
Обязательство зависит от контекста.

**Обогащение**:
- Π&(p:Priority). O_p A — с приоритетами
- Σ⊕(a:Agent). O_a A — кто обязан
- Π⅋(cond:Condition). O A — условное обязательство

#### 11.4.2 Разрешено (P)

**Определение**:
```
P : Lin → Lin
P A = μX. A ⊕ (X & Grant)
```

**Построение**:
```
P = μ ∘ ((K_A) ⊕ (Id & K_Grant))
```

**Интерпретация**: Индуктивная последовательность разрешений.

**Дуальность**: O и P функционально дуальны (ν ↔ μ).

### 11.5 Алетические модальности

#### 11.5.1 Необходимо (□_N)

**Определение**:
```
□_N : (World → Type) → Type
□_N A = Π&(w:World). A(w)
```

**Построение**: Через Π& по возможным мирам.

**Интерпретация**: A истинно во всех возможных мирах.

**С зависимыми типами**:
```
□_R : Σ⊗(w₀:World). Π&(w:World, R(w₀,w)). A(w)
```
Через отношение доступности R.

**Обогащение**:
- Σ⊗(n:ℕ). □ⁿ_N A — с модальной глубиной
- Π&(w:World). (A(w) ⊗ Prob(w)) — взвешенная необходимость

#### 11.5.2 Возможно (◇_N)

**Определение**:
```
◇_N : (World → Type) → Type
◇_N A = Σ⊕(w:World). A(w)
```

**Построение**: Через Σ⊕ по мирам.

**Интерпретация**: A истинно в некотором мире.

**Дуальность**: □_N и ◇_N дуальны (Π& ↔ Σ⊕).

### 11.6 Эпистемические модальности

#### 11.6.1 Знание агента (K_a)

**Определение**:
```
K_a : (State_a → Type) → Type
K_a A = Π&(s:State_a). A(s)
```

**Построение**: Через Π& по состояниям агента a.

**Интерпретация**: Агент a знает A, если A истинно во всех состояниях, которые агент считает возможными.

**С зависимыми типами**:
```
K_a^t : Π&(s:State_a(t)). A(s) -- временное знание
```

**Обогащение**:
- K_a(Σ⊗(b:Agent). K_b A) — знание о знании других
- Σ⊗(c:Confidence). (K_a A ⊗ c) — с уровнем уверенности
- Π⅋(e:Evidence). K_a A — условное знание

#### 11.6.2 Общее знание (C)

**Определение**:
```
C : (Agent → Type) → Type
C A = νX. A & (Π&(a:Agent). K_a X)
```

**Построение**:
```
C = ν ∘ ((K_A) & (Π&(a:Agent). K_a ∘ Id))
```

**Интерпретация**: Коиндуктивное: все знают A, все знают что все знают A, и так далее.

**Правила**:
- **base**: π₁ : C A → A
- **induction**: π₂ : C A → Π&(a:Agent). K_a(C A)

**С зависимыми типами**:
```
C_G : Σ⊗(G:Group). (νX. A & (Π&(a:G). K_a X))
```
Общее знание в группе G.

### 11.7 Вероятностные модальности

#### 11.7.1 С вероятностью p (□_p)

**Определение**:
```
□_p : Lin → Lin
□_p A = A ⊗ Prob(p)
```

**Построение**: Простой тензор с типом вероятности.

**Функториальность**: Очевидна (композиция с K_Prob(p)).

**С зависимыми типами**:
```
□_cond : Σ⊗(e:Evidence). (A ⊗ Prob(A|e))
```
Условная вероятность.

**Обогащение**:
- Π⅋(obs:Observation). (□_p A → □_{p'} A) — байесовское обновление

#### 11.7.2 Распределение (D)

**Определение**:
```
D : Lin → Lin
D A = Σ⊕(n:ℕ). (A^⊗n ⊗ Distribution(n))
```

**Построение**:
```
D = Σ⊕(n:ℕ) ∘ ((−)^⊗n ⊗ K_Distribution(n))
```

**Интерпретация**: Дискретное вероятностное распределение над A.

**С зависимыми типами**:
```
D_θ : Σ⊗(θ:Parameters). D_θ A
```
Параметризованные распределения.

### 11.8 Афинные и релевантные модальности

#### 11.8.1 Афинная (◯)

**Определение**:
```
◯ : Lin → Lin
◯A = A ⊕ 1
```

**Построение**:
```
◯ = (−) ⊕ K_1
```

**Интерпретация**: Ресурс A можно использовать или отбросить.

**Правила**:
- **use**: inl : A → ◯A
- **discard**: inr : 1 → ◯A

**С зависимыми типами**:
```
◯_cond : Π⅋(cond:Condition). (A ⊕ 1(cond))
```
Условная афинность.

#### 11.8.2 Релевантная (◉)

**Определение**:
```
◉ : Lin → Lin
◉A = μX. A ⊕ (A ⊗ X)
```

**Построение**:
```
◉ = μ ∘ ((K_A) ⊕ ((K_A) ⊗ Id))
```

**Интерпретация**: Минимум одно использование A, возможно больше.

**С зависимыми типами**:
```
◉_n : Σ⊗(n:ℕ_{>0}). A^⊗n
```
Точная релевантность — ровно n использований.

### 11.9 Градуированные модальности

#### 11.9.1 Ровно n (□_n)

**Определение**:
```
□_n : Lin → Lin
□_n A = A^⊗n
```

**Построение**: n-кратный тензор.

**Функториальность**: Композиция n копий функтора.

**С зависимыми типами**:
```
□_dep : Σ⊗(n:ℕ). □_n(A(n))
```
Градация зависит от типа.

#### 11.9.2 До n (□_≤n)

**Определение**:
```
□_≤n : Lin → Lin
□_≤n A = Σ⊕(k:ℕ_{≤n}). A^⊗k
```

**Построение**: Копроизведение по k ∈ [0, n].

**Интерпретация**: От 0 до n использований A.

#### 11.9.3 Минимум n (□_≥n)

**Определение**:
```
□_≥n : Lin → Lin
□_≥n A = A^⊗n ⊗ !A
```

**Построение**: n использований + неограниченный остаток.

**Интерпретация**: Минимум n, возможно бесконечно.

**С зависимыми типами**:
```
□_interval : Σ⊗(n,m:ℕ, n≤m). (Σ⊕(k:ℕ_{[n,m]}). A^⊗k)
```
Интервальная градация [n, m].

### 11.10 Категорная структура модальных функторов

#### Монады и комонады

**Комонады**:
- ! — экспоненциальная комонада
- O — деонтическая комонада (обязательство)
- C — эпистемическая комонада (общее знание)

**Структура**:
```
ε : □A → A (counit)
δ : □A → □□A (comultiplication)
```

**Монады**:
- ? — экспоненциальная монада
- P — деонтическая монада (разрешение)
- ◇ — темпоральная монада (когда-нибудь)

**Структура**:
```
η : A → ◇A (unit)
μ : ◇◇A → ◇A (multiplication)
```

#### Сопряжения (Adjunctions)

**Темпоральные**: □ ⊣ ◇ (функционально, через ν ⊣ μ)

**Экспоненциальные**: ! ⊣ ? (функциональная дуальность)

**Пространственные**: □_S ⊣ ◇_S (через Π& ⊣ Σ⊕)

**Алетические**: □_N ⊣ ◇_N (через Π& ⊣ Σ⊕)

#### Композиция модальностей

Модальности композируются как функторы:

```
(!□) : Lin → Lin
(!□)A = !(□A) -- бесконечное использование потока
```

```
(□!) : Lin → Lin
(□!)A = □(!A) -- поток бесконечно используемых значений
```

```
(K_a ∘ □) : Lin → Lin
(K_a ∘ □)A = K_a(□A) -- агент знает, что A всегда истинно
```

**Коммутативность**: Некоторые модальности коммутируют:
```
□_S ∘ □_t ≅ □_t ∘ □_S -- время и пространство независимы
```

**Некоммутативность**: Другие не коммутируют:
```
K_a ∘ □ ≠ □ ∘ K_a -- знание о будущем vs. гарантированное будущее знание
```

### 11.11 Дифференцирование модальностей

**Экспоненциальные**:
```
∂(!A) ≅ !A ⊗ A -- выделить одно использование
∂(?A) ≅ ?A ⊗ A -- удалить один элемент из мультимножества
```

**Темпоральные**:
```
∂(□A) ≅ ℕ ⊗ A -- позиция в потоке
∂(◇A) ≅ ℕ ⊗ A -- номер шага
∂(A U B) ≅ Σ⊗(n:ℕ). (A^⊗n ⊗ B) -- путь до B
```

**Пространственные**:
```
∂(□_S A) ≅ Σ⊗(l:Location). A(l) -- фокус в одной локации
∂(◇_S A) ≅ 0 -- уже выбрана локация
```

**Алетические**:
```
∂(□_N A) ≅ Σ⊗(w:World). A(w) -- фокус в одном мире
```

**Градуированные**:
```
∂(□_n A) ≅ n ⊙ A^⊗(n-1) -- убрать одно из n
∂(◉A) ≅ Σ⊗(n:ℕ). A^⊗n -- позиция в цепочке
```

**Интерпретация**: Производная модальности описывает "контекст фокуса" внутри модальной структуры.

### 11.12 Роль зависимых типов в модальностях

**Обогащение через четыре зависимых связки**:

1. **Σ⊗ (зависимая тензорная сумма)**:
 - Параметризация модальностей
 - Σ⊗(t:Time). □_{≥t} A(t) — временная параметризация
 - Σ⊗(c:Context). O_c A — контекстное обязательство

2. **Π⅋ (зависимое par-произведение)**:
 - Условные модальности
 - Π⅋(cond:Condition). O A — условное обязательство
 - Π⅋(e:Evidence). K_a A — условное знание

3. **Π& (зависимое аддитивное произведение)**:
 - Индексированные модальности
 - Π&(t:Time). A(t) — темпоральное индексирование
 - Π&(w:World). A(w) — модальное индексирование
 - Π&(l:Location). A(l) — пространственное индексирование
 - Π&(a:Agent). K_a A — мультиагентное индексирование

4. **Σ⊕ (зависимая аддитивная сумма)**:
 - Выбор варианта с зависимостью
 - Σ⊕(w:World). A(w) — выбор мира
 - Σ⊕(l:Location). A(l) — выбор локации

**Теорема**: Зависимые типы увеличивают выразительную мощь модальностей экспоненциально, позволяя создавать параметризованные, индексированные и условные модальные системы.

### 11.13 Резюме по модальным функторам

**Архитектура**:
- **Базовые функторы (разделы 1-8)**: MALL, зависимые типы, (ко)индукция, дифференцирование
- **Модальные функторы (раздел 11)**: Определяемые расширения

**Принцип построения**: Любая модальность, выразимая через:
- (Ко)индуктивные типы (μ, ν)
- MALL-связки (⊗, ⅋, &, ⊕)
- Зависимые функторы (Σ⊗, Π⅋, Π&, Σ⊕)

может быть определена как функтор в [**Lin**, **Lin**].

**Категорная структура модальностей**:
1. Многие модальности — (ко)монады
2. Существуют сопряжения между дуальными модальностями
3. Модальности композируются функториально
4. Все модальности дифференцируемы

**Практическое значение**:
- **Верификация**: Темпоральные модальности для model checking
- **Распределённые системы**: Пространственные модальности
- **Мультиагентные системы**: Эпистемические модальности
- **Нормативные системы**: Деонтические модальности
- **Ресурсы**: Градуированные и афинные модальности
- **Вероятность**: Вероятностные модальности

**Преимущества единообразного подхода**:
- Общая теория для всех модальностей
- Автоматическое наследование свойств (функториальность, дифференцируемость)
- Композициональность модальных систем
- Роль зависимых типов в обогащении модальностей

## 12. Резюме: универсальность базовых функторов

**Архитектура системы функторов**:
- **Разделы 1-9**: Базовая система (примитивные, MALL, зависимые, неподвижные точки, комбинаторы, дифференцирование)
- **Раздел 10**: Вычислительная интерпретация
- **Раздел 11**: Модальные функторы (определяемые расширения)
- **Раздел 12**: Резюме и теоремы полноты

### Полная система базовых функторов

**Минимальный базис для полиномиальных функторов**:
1. **Примитивные**: Id, K_C, Δ
2. **MALL-функторы**: ⊗, &, ⊕ (бифункторы на объектах)
3. **Зависимые функторы**: Σ⊗, Π&, Σ⊕
4. **Операторы неподвижных точек**: μ, ν

**Расширенный базис**:
5. **Дуальные мультипликативные**: ⅋, Π⅋
6. **Дифференциальный**: ∂
7. **Модальные**: !, ? (определяются через базис)

**Функториальные комбинаторы** (операции над функторами):
- Композиция (∘)
- Тензорное произведение функторов (⊗)
- Аддитивная конъюнкция функторов (&)
- Аддитивная дизъюнкция функторов (⊕)
- Par функторов (⅋)
- Дифференцирование функторов (∂)
- Частичное применение бифункторов

**Наследование структуры**: Комбинаторы ⊗, &, ⊕, ⅋ на функторах наследуют свойства одноимённых связок из категории **Lin**. Дифференциальный оператор ∂ наследует дифференциальную структуру.

### Полнота базиса (Proposition — proof sketch)

**Утверждение**: Любой строго позитивный полиномиальный функтор F : **Lin** → **Lin** может быть построен из базовых функторов и комбинаторов.

*Набросок доказательства*: Индукция по структуре строго позитивного функтора. Базовый случай: Id и K_C покрывают переменные и константы. Индуктивный шаг: ⊗, &, ⊕ замкнуты относительно строгой позитивности; Σ⊗, Π&, Σ⊕ обеспечивают зависимые обобщения; μ и ν — неподвижные точки. Полная формализация — предмет дальнейшей работы (см. также Agda-код в `code/agda/`).

**Следствие**: Система базовых функторов **универсальна** для описания типов данных в категории **Lin**.

### Дифференциальная полнота

**Теорема**: Для любого функтора F, построенного из базовых функторов, производная ∂F корректно определена и является функтором.

**Следствие**: [**Lin**, **Lin**] является **дифференциальной категорией**.

**Ключевые свойства дифференцирования**:
1. **Правило Лейбница**: ∂(F ⊗ G) = (∂F ⊗ G) ⊕ (F ⊗ ∂G)
2. **Цепное правило**: ∂(G ∘ F) = (∂G ∘ F) ⊗ ∂F
3. **Линейность**: ∂(F ⊕ G) = ∂F ⊕ ∂G
4. **Универсальность**: Все функторы дифференцируемы (благодаря ультрафинитизму)

**Интерпретация**: ∂F(A) — это тип одноточечных контекстов ("дырок") в структуре F(A). Высшие производные ∂ⁿF описывают n-точечные контексты.

### Модальная выразительность

**Теорема**: Любая модальность, выразимая через (ко)индуктивные типы, MALL-связки и зависимые функторы, может быть определена как функтор в [**Lin**, **Lin**].

**Примеры модальных функторов**:

1. **Экспоненциальные**:
 - ! = νX. 1 ⊕ (A & X) — комонада "of course"
 - ? = μX. ⊤ ⊕ (A ⊗ X) — монада "why not"
 - Функциональная дуальность: ! ⊣ ?

2. **Темпоральные**:
 - □ = νX. A & X — всегда в будущем
 - ◇ = μX. A ⊕ X — когда-нибудь
 - A U B = μX. B ⊕ (A ⊗ X) — until
 - A R B = νX. B & (A ⅋ X) — release

3. **Пространственные**:
 - □_S = Π&(l:Location). A(l) — везде
 - ◇_S = Σ⊕(l:Location). A(l) — где-то

4. **Деонтические**:
 - O = νX. A & (X ⊕ Violation) — обязательно
 - P = μX. A ⊕ (X & Grant) — разрешено

5. **Алетические**:
 - □_N = Π&(w:World). A(w) — необходимо
 - ◇_N = Σ⊕(w:World). A(w) — возможно

6. **Эпистемические**:
 - K_a = Π&(s:State_a). A(s) — знание агента
 - C = νX. A & (Π&(a:Agent). K_a X) — общее знание

7. **Градуированные**:
 - □_n = A^⊗n — ровно n использований
 - □_≤n = Σ⊕(k:ℕ_{≤n}). A^⊗k — до n
 - □_≥n = A^⊗n ⊗ !A — минимум n

**Категорная структура модальностей**:
- Многие модальности являются (ко)монадами
- Существуют сопряжения между дуальными модальностями
- Модальности композируются функториально
- Все модальности дифференцируемы

**Роль зависимых типов**: Зависимые функторы (Σ⊗, Π⅋, Π&, Σ⊕) экспоненциально увеличивают выразительность модальностей, позволяя создавать параметризованные, индексированные и условные модальные системы.

**Следствие**: Система функторов **Lin** обеспечивает единообразную основу для разнообразных модальных логик.

### Категорная структура [Lin, Lin]

Категория эндофункторов наследует и обогащает структуру **Lin**:

1. **Моноидальная структура**:
 - Композиция (∘) с единицей Id
 - Тензор (⊗) с единицей K_1
 
2. **Биноидальная структура**:
 - Произведение (&) с проекциями
 - Копроизведение (⊕) с инъекциями
 
3. ***-автономная структура**:
 - Дуальный тензор (⅋)
 - Наследование дуальности из **Lin**
 
4. **Дифференциальная структура**:
 - Оператор ∂ : [Lin → Lin] → [Lin → Lin]
 - Дистрибутор δ⊗ и цепное правило chain
 - Высшие производные ∂ⁿ

### Практическое значение

**Для теории категорий**:
- **Универсальность**: Базис выражает все полиномиальные функторы
- **Дифференцируемость**: Все конструкции имеют производные
- **Наследование**: Структура **Lin** поднимается на [**Lin**, **Lin**]
- **Полнота**: Система замкнута относительно всех операций

**Для программирования**:
- **Модульность**: Сложные типы данных строятся из простых частей
- **Композициональность**: Свойства функторов композируются
- **Верификация**: Функториальные законы проверяются на базовых функторах
- **Навигация**: Производные дают зипперы (контексты с дырками)
- **Эффективность**: Дифференцирование автоматически генерирует структуры для обхода
- **Модальности**: Единообразная основа для эффектов, ресурсов, времени, пространства

**Для теории типов**:
- **Выразительность**: Зависимые типы + (ко)индукция + дифференциалы + модальности
- **Конструктивность**: Все конструкции вычислимы
- **Ультрафинитизм**: Размеры гарантируют терминацию дифференцирования
- **Реализация**: Базис для компиляторов и proof assistants
- **Модальные системы**: Темпоральные, пространственные, эпистемические логики

**Применения модальностей**:
- **Верификация**: Темпоральные модальности (□, ◇, U, R) для model checking
- **Распределённые системы**: Пространственные модальности (□_S, ◇_S)
- **Мультиагентные системы**: Эпистемические модальности (K_a, C)
- **Нормативные системы**: Деонтические модальности (O, P)
- **Управление ресурсами**: Градуированные модальности (□_n, □_≤n)
- **Вероятностные вычисления**: Вероятностные модальности (□_p, D)
- **Линейная логика**: Экспоненциальные модальности (!, ?)

**Примеры применений дифференцирования**:
- ∂(List_A) ≅ List_A ⊗ A — зиппер для списка
- ∂(Tree_A) ≅ Tree_A ⊗ Bool ⊗ Tree_A — путь в дереве
- ∂(Stream_A) ≅ ℕ — позиция в потоке
- ∂(!A) ≅ !A ⊗ A — выделение одного использования из многих
- ∂(□A) ≅ ℕ ⊗ A — позиция в темпоральном потоке
- ∂²F — редактирование с двумя курсорами
