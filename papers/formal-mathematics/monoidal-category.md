# Моноидальная категория: Дифференциальная линейная логика с зависимыми типами

## 1. Базовая структура

### 1.1 Категория **Lin**

- **Объекты**: Типы A, B, C, … (включая зависимые типы)
- **Морфизмы**: Hom(A, B) = { t | x:A ⊢ t : B } — линейные термы
- **Композиция**: Подстановка термов g ∘ f = g[f/x]
- **Тождество**: id_A = x:A ⊢ x:A

## 2. Моноидальная структура

### 2.1 Симметричная моноидальная категория (⊗, 1)

**Тензорное произведение**:
- Функтор ⊗ : **Lin** × **Lin** → **Lin**
- На объектах: (A, B) ↦ A ⊗ B
- На морфизмах: (f : A → C, g : B → D) ↦ f ⊗ g : A ⊗ B → C ⊗ D

**Единичный объект**: I = 1

**Естественные изоморфизмы**:
- Ассоциатор: α_{A,B,C} : (A ⊗ B) ⊗ C ≅ A ⊗ (B ⊗ C)
- Левый унитор: λ_A : 1 ⊗ A ≅ A
- Правый унитор: ρ_A : A ⊗ 1 ≅ A
- Симметрия: σ_{A,B} : A ⊗ B ≅ B ⊗ A

**Диаграммы когерентности**: Пентагон и треугольник коммутируют.

### 2.2 Дуальная моноидальная структура (⅋, ⊥)

Par-произведение ⅋ даёт вторую моноидальную структуру с единицей ⊥.

**Линейное отрицание**: Контравариантный функтор (−)⊥ : **Lin**^op → **Lin**:
- (A ⊗ B)⊥ = A⊥ ⅋ B⊥
- (A ⅋ B)⊥ = A⊥ ⊗ B⊥
- 1⊥ = ⊥, ⊥⊥ = 1
- (A ⊸ B)⊥ = A ⊗ B⊥

## 3. Биноидальная структура (&, ⊕)

Категория **Lin** является биноидальной с двумя дополнительными произведениями:

### 3.1 Категориальное произведение (&, ⊤)

- A & B — аддитивная конъюнкция
- Проекции: π₁ : A & B → A, π₂ : A & B → B
- Универсальное свойство: для f : C → A и g : C → B существует единственное ⟨f, g⟩ : C → A & B

### 3.2 Категориальная копроизведение (⊕, 0)

- A ⊕ B — аддитивная дизъюнкция
- Инъекции: inl : A → A ⊕ B, inr : B → A ⊕ B
- Универсальное свойство: для f : A → C и g : B → C существует единственное [f, g] : A ⊕ B → C

### 3.3 Дистрибутивность

Тензор дистрибутивен над коопродуктом:
```
A ⊗ (B ⊕ C) ≅ (A ⊗ B) ⊕ (A ⊗ C)
```

## 4. Зависимые типы: индексированная моноидальная структура

Категория **Lin** обладает индексированной моноидальной структурой, где зависимые типы представлены через четыре отдельные конструкции.

### 4.1 Мультипликативные зависимые типы

#### 4.1.1 Зависимая сумма Σ⊗

Для каждого типа A существует функтор:
```
Σ⊗_A : Lin/A → Lin
```
где Lin/A — срез категории над A (типы семейства B с отображением в A).

**Универсальное свойство**: Для семейства B : A → Type существует изоморфизм:
```
Hom(C, Σ⊗(x:A).B(x)) ≅ Σ_{f : Hom(C,A)} Hom(C, B(f))
```

**Связь с ⊗**: Σ⊗ расширяет тензорное произведение:
- Если B не зависит от x, то Σ⊗(x:A).B ≅ A ⊗ B
- Проекция: π₁ : Σ⊗(x:A).B → A

**Устранение**: 
```
 C ⊗ Σ⊗(x:A).B(x)
 ↓
 C ⊗ A ⊗ B (распаковка)
```

#### 4.1.2 Зависимое произведение Π⅋

Для каждого типа A существует функтор:
```
Π⅋_A : Lin/A → Lin
```

**Универсальное свойство**: Для семейства B : A → Type:
```
Hom(Π⅋(x:A).B(x), C) ≅ Π_{a : A} Hom(B(a), C)
```

**Связь с ⅋**: Π⅋ расширяет par-произведение:
- Применение через par: (f : Π⅋(x:A).B) ⅋ (a : A) → B(a)
- Контексты комбинируются через ⅋

**Введение**:
```
 Γ ⅋ A → B
 ──────────────
 Γ → Π⅋(x:A).B
```

### 4.2 Аддитивные зависимые типы

#### 4.2.1 Индексированное произведение Π&

Для индексного множества I, Π&(i:I).A(i) — это произведение семейства типов.

**Категорная интерпретация**: Это предел конуса:
```
 Π&(i:I).A(i)
 / | \
 / | \
 / | \
 A(i₁) A(i₂) A(i₃) ...
```

**Проекции**: Для каждого i:I существует:
```
π_i : Π&(i:I).A(i) → A(i)
```

**Универсальное свойство**: Для любого C с семейством морфизмов {f_i : C → A(i)}_{i:I} существует единственный:
```
⟨f_i⟩_{i:I} : C → Π&(i:I).A(i)
```

**Связь с &**: 
- Для I = {0, 1}: Π&(i:{0,1}).A(i) ≅ A(0) & A(1)
- Контекст Γ используется одинаково для всех индексов

#### 4.2.2 Индексированная копроизведение Σ⊕

Для индексного множества I, Σ⊕(i:I).A(i) — это копроизведение семейства типов.

**Категорная интерпретация**: Это копредел кокануса:
```
 A(i₁) A(i₂) A(i₃) ...
 \ | /
 \ | /
 \ | /
 Σ⊕(i:I).A(i)
```

**Инъекции**: Для каждого конкретного индекса i₀:I и значения a : A(i₀):
```
in_{i₀} : A(i₀) → Σ⊕(i:I).A(i)
```

**Универсальное свойство**: Для любого C с семейством морфизмов {g_i : A(i) → C}_{i:I} существует единственный:
```
[g_i]_{i:I} : Σ⊕(i:I).A(i) → C
```

**Связь с ⊕**:
- Для I = {0, 1}: Σ⊕(i:{0,1}).A(i) ≅ A(0) ⊕ A(1)
- При устранении контекст Δ используется линейно

### 4.3 Индексированная моноидальная категория

Зависимые типы превращают **Lin** в **индексированную моноидальную категорию**:

**Для мультипликативных связок**:
- Семейство моноидальных категорий {Lin/A}_{A:Type}
- Функторы замены базы (reindexing) между ними
- Σ⊗ и Π⅋ — (ко)пределы в этой структуре

**Для аддитивных связок**:
- Π& и Σ⊕ — (ко)пределы по дискретным категориям индексов
- Сохраняют биноидальную структуру (&, ⊕)

### 4.4 Взаимодействие между связками

**Дистрибутивность Σ⊗ над Σ⊕**:
```
Σ⊗(x:A).(Σ⊕(i:I).B(x,i)) ≅ Σ⊕(i:I).(Σ⊗(x:A).B(x,i))
```

**Дистрибутивность ⊗ над Σ⊕**:
```
C ⊗ Σ⊕(i:I).A(i) ≅ Σ⊕(i:I).(C ⊗ A(i))
```

**Коммутация Π& с Π&**:
```
Π&(i:I).(Π&(j:J).A(i,j)) ≅ Π&(j:J).(Π&(i:I).A(i,j))
```

## 5. (Ко)индуктивные типы

### 5.1 Начальные алгебры (μ)

Индуктивный тип μX.F(X) — начальная алгебра для функтора F:
```
fold : F(μX.F(X)) → μX.F(X)
```

**Универсальное свойство**: Для любой F-алгебры α : F(C) → C существует единственный морфизм (катаморфизм):
```
cata(α) : μX.F(X) → C
```
такой что диаграмма коммутирует:
```
F(μX.F(X)) --F(cata(α))--> F(C)
 | |
 fold α
 | |
 v v
 μX.F(X) ----cata(α)-----> C
```

### 5.2 Терминальные коалгебры (ν)

Коиндуктивный тип νX.F(X) — терминальная коалгебра:
```
unfold : νX.F(X) → F(νX.F(X))
```

**Универсальное свойство**: Для любой F-коалгебры γ : C → F(C) существует единственный морфизм (анаморфизм):
```
ana(γ) : C → νX.F(X)
```

#### Позитивность и линейное отрицание

**Условие существования**: Для существования начальной алгебры (μ) и терминальной коалгебры (ν), функтор F : **Lin** → **Lin** должен быть **строго ковариантным**.

**В контексте MALL с линейным отрицанием (−)⊥**:

**Позитивные позиции** (ковариантные) для переменной X:
- X в A ⊗ X, X ⊗ A — позитивно
- X в A ⅋ X, X ⅋ A — позитивно
- X в A & X, X & A — позитивно
- X в A ⊕ X, X ⊕ A — позитивно
- X в A ⊸ X — позитивно (кодомен функции)

**Негативные позиции** (контравариантные):
- X в X ⊸ A — негативно (домен функции)
- X⊥ в любой позитивной позиции — негативно (отрицание меняет вариантность)

**Текущее ограничение системы**: 
```
μX. F(X) и νX. F(X)
```
где F может использовать только **позитивные вхождения** X. Явное использование X⊥ в определении F **запрещено**.

**Категорная интерпретация**: Функтор F должен быть ковариантным эндофунктором на **Lin**:
```
F : Lin → Lin (ковариантный)
```

Если бы мы допускали F(X, X⊥), это был бы функтор:
```
F : Lin × Lin^op → Lin (биваринтный)
```
что требует более сложных условий для существования неподвижных точек.

**Решение**:
1. В базовой системе используются только ковариантные функторы
2. MALL-связки (⊗, ⅋, &, ⊕) естественно ковариантны по обоим аргументам
3. Линейная импликация A ⊸ B ковариантна по B, но контравариантна по A
4. Зависимые связки (Σ⊗, Π⅋, Π&, Σ⊕) также соблюдают позитивность

**Преимущества ограничения**:
- Гарантированное существование (начальных алгебр / терминальных коалгебр)
- Простота проверки корректности определений
- Естественная композиция с другими конструкциями

**Отрицание доступно снаружи**:
```
(μX.F(X))⊥ и (νX.F(X))⊥
```
применяются к готовым типам, а не внутри рекурсивного определения.

### 5.3 Размерные типы (Sized Types)

Категория **Lin** включает **размерные типы**, обеспечивающие точный контроль над (ко)индуктивными типами.

#### 5.3.1 Категория размеров

**Размеры** образуют частично упорядоченную структуру:
```
Size := {0, 1, 2, ..., ∞} где ∞ := 100500^100500
```

с отношением порядка 0 ≤ 1 ≤ 2 ≤ ... ≤ ∞.

**Размерные типы**:
- μ^α X.F(X) — индуктивный тип размера α
- ν^α X.F(X) — коиндуктивный тип размера α

#### 5.3.2 Функториальность по размеру

Для каждого функтора F существует семейство функторов:
```
F^α : Lin → Lin для каждого α : Size
```

с морфизмами согласования:
```
α ≤ β ⟹ F^α ⇒ F^β (естественная трансформация)
```

#### 5.3.3 Универсальные свойства с размерами

**Начальная алгебра размера α**:
```
fold^α : F(μ^α X.F(X)) → μ^α X.F(X)
```

с катаморфизмом:
```
cata^α : F-Alg → Hom(μ^α X.F(X), C)
```

**Терминальная коалгебра размера α**:
```
unfold^α : ν^α X.F(X) → F(ν^α X.F(X))
```

#### 5.3.4 Ультрафинитизм: размер по умолчанию

**Философия**: По умолчанию все типы имеют размер ∞ = 100500^100500. Это реализует форму **ультрафинитизма**:
- Все типы теоретически конечны
- ∞ достаточно велико для практических целей
- Избегает парадоксов актуальной бесконечности
- Позволяет финитные рассуждения о "почти бесконечных" структурах

**Категорная интерпретация**: Категория **Lin** факторизуется через семейство подкатегорий:
```
Lin = ⋃_{α:Size} Lin^α
```
где Lin^α содержит типы размера ≤ α.

#### 5.3.5 Субтипирование

Функторы:
```
forget_α^β : Lin^α → Lin^β при α ≤ β
```

дают субтипирование:
```
μ^α X.F(X) <: μ^β X.F(X) (ковариантно)
ν^β X.F(X) <: ν^α X.F(X) (контравариантно)
```

## 6. Дифференциальная структура

### 6.1 Дифференциальная категория

**Lin** с оператором ∂ образует дифференциальную категорию.

**Связь с размерными типами**: Ультрафинитизм (∞ = 100500^100500 из раздела 5.3) обеспечивает корректность дифференцирования для **всех** типов категории **Lin**:
- Производная ∂(μ^α X.F(X)) определена и вычислима для любого α
- Производная ∂(ν^α X.F(X)) также определена благодаря финитности α 
- Размер по умолчанию ∞ достаточно велик практически, но конечен теоретически
- Это позволяет универсально дифференцировать любые (ко)индуктивные типы без ограничений

Финитность — ключевое свойство для корректности дифференциальной структуры.

**Основные свойства**:

1. **Функтор дифференцирования**: ∂ : **Lin** → **Lin**
 - На объектах: A ↦ ∂A
 - На морфизмах: f : A → B ↦ ∂f : A ⊗ ∂A → ∂B

2. **Правило Лейбница**: 
 ```
 ∂(f ⊗ g) = (∂f ⊗ g) ⊕ (f ⊗ ∂g)
 ```

3. **Правило цепочки**:
 ```
 ∂(g ∘ f) = (∂g ∘ f) ⊗ ∂f
 ```

4. **Линейность производной**: ∂² = 0 (производная линейного отображения константна)

### 6.2 Взаимодействие дифференцирования с ! и ∂

Дифференцирование экспоненциального объекта:
```
∂(!A) ≅ !A ⊗ A
```

Это выражает классический факт: производная eˣ есть eˣ.

**Связь с кодеривацией**: Морфизм f : !A → B имеет производную:
```
∂f : !A ⊗ A → B
```

## 7. Моноидальная замкнутость

### 8.1 Внутренний hom (⊸)

Линейная импликация A ⊸ B — внутренний hom для ⊗:
```
Hom(C ⊗ A, B) ≅ Hom(C, A ⊸ B)
```

**Оценка**: ev : (A ⊸ B) ⊗ A → B

**Карринг**: Λ : Hom(C ⊗ A, B) → Hom(C, A ⊸ B)

### 8.2 Замкнутость для &

Импликация для & (интуиционистская импликация):
```
Hom(C & A, B) ≅ Hom(C, A ⇒ B)
```

где A ⇒ B = !A ⊸ B.

## 8. Трассировка и компактная замкнутость

### 9.1 Компактная замкнутость для конечных типов

Для конечномерных типов существует дуальный объект:
```
A* = A ⊸ 1
```

с естественными изоморфизмами:
```
η_A : 1 → A ⊗ A*
ε_A : A* ⊗ A → 1
```

### 9.2 Трассировый оператор

Для петель: Tr^A_B : Hom(A ⊗ X, B ⊗ X) → Hom(A, B)

Связь с дифференцированием:
```
Tr(∂f) = ∂(Tr(f))
```

## 9. Enrichment и двойные категории

### 10.1 Self-enrichment

**Lin** обогащена над собой:
```
Hom(A, B) = A ⊸ B
```

Композиция:
```
∘ : (B ⊸ C) ⊗ (A ⊸ B) → (A ⊸ C)
```

### 10.2 Двойная категория

Дифференциальная структура индуцирует двойную категорию:
- **Горизонтальные морфизмы**: Обычные морфизмы f : A → B
- **Вертикальные морфизмы**: Дифференциалы ∂A → ∂B
- **Клетки**: Коммутирующие квадраты производных

## 10. Функториальная семантика

### 11.1 Интерпретация в векторных пространствах

Функтор ⟦−⟧ : **Lin** → **Vect**_k:
- ⟦A ⊗ B⟧ = ⟦A⟧ ⊗_k ⟦B⟧
- ⟦A ⊕ B⟧ = ⟦A⟧ ⊕ ⟦B⟧
- ⟦∂A⟧ = T⟦A⟧ (касательное расслоение)

### 11.2 Реляционная семантика

Функтор в **Rel** (категорию отношений):
- Интерпретирует линейность как "ровно одно использование"
- ⟦A ⊗ B⟧ = ⟦A⟧ × ⟦B⟧
- ⟦A ⅋ B⟧ = ⟦A⟧ ⊎ ⟦B⟧

## 11. Модальности

**Важное замечание**: Базовая структура категории **Lin** (разделы 1-10) определяется через MALL-связки, зависимые типы, (ко)индуктивные типы и дифференцирование. Модальности **не являются частью базовой системы**, но структура категории позволяет их естественным образом задать через (ко)индуктивные типы.

### 11.1 Экспоненциальные модальности: комонада ! и монада ?


Экспоненциальные модальности ! (of course) и ? (why not) позволяют управлять нелинейным использованием ресурсов в линейной логике. Они могут быть построены как (ко)индуктивные типы несколькими способами.

### 11.1.1 Комонада ! (of course)

Комонада ! переводит линейный тип в тип, который можно использовать произвольное количество раз (включая 0 и много раз).

#### 6.1.1 Основное построение: коиндуктивный тип с аддитивным выбором

**Определение**:
```
!A := νX. 1 ⊕ (A & X)
```

**Категорная интерпретация**: Это терминальная коалгебра для функтора F(X) = 1 ⊕ (A & X):
```
unfold : !A → 1 ⊕ (A & !A)
```

Структура: коиндуктивный тип с деструктором:
- `unfold(x) = inl(*)` : завершение (пустой поток)
- `unfold(x) = inr(a, x')` где `(a, x') : A & !A` : предложение элемента с продолжением

**Ключевая семантика**: Аддитивная конъюнкция `A & !A` означает, что **потребитель выбирает**:
- π₁ : взять элемент типа A (используя dereliction)
- π₂ : продолжить разворачивать поток !A (используя остаток)

Это создаёт "поток возможностей" — коиндуктивную структуру, где на каждом шаге доступен выбор между элементом и продолжением.

**Универсальное свойство** (анаморфизм): Для любой коалгебры γ : C → 1 ⊕ (A & C) существует единственный морфизм:
```
ana(γ) : C → !A
```
такой что:
```
 C ----------ana(γ)--------> !A
 | |
 γ unfold
 | |
 v v
1 ⊕ (A & C) --1⊕(A&ana(γ))--> 1 ⊕ (A & !A)
```

**Комонадные операции**:

**Коединица** ε_A : !A → A:
```
ε_A = ana([error, π₁]) где error : 1 → A невозможен
```
Извлекает первый доступный элемент из потока.

**Коумножение** δ_A : !A → !!A:
```
δ_A(x) = ana(λy. inr((y, δ_A(y))))
```
Создаёт "поток потоков" — каждый элемент сам является потоком !A.

**Weakening** w_A : !A → 1:
```
w_A(x) = *
```
Игнорирует поток.

**Связь со структурами**: Коиндуктивное определение через νX. 1 ⊕ (A & X) естественно выражает "ленивое мультимножество" с недетерминированным выбором потребителя на каждом шаге.

#### 6.1.2 Альтернативные построения

**Индексированное произведение**:
```
!A := Π&(n:ℕ). (A^⊗n)
```
Предел над семейством тензорных степеней. Более абстрактное, но эквивалентное представление.

**Через свободную коммутативную моноиду**:
```
!A := νX. ⊤ & (A ⊗ X)
```
или как предел с факторизацией:
```
!A := lim_{n:ℕ} (A^⊗n / Sₙ)
```
где Sₙ — симметрическая группа. Факторизация по перестановкам даёт коммутативность.

**Операдный подход**:
```
!A := Σ⊕(n:ℕ). (A^⊗n / Sₙ)
```
Использует операду коммутативных моноид.

### 11.1.2 Монада ? (why not)

Монада ? дуальна комонаде ! и описывает конечные мультимножества — способность предоставить произвольное (но конечное) количество значений.

#### 6.2.1 Основное построение: индуктивный тип мультимножеств

**Определение**:
```
?A := μX. ⊤ ⊕ (A ⊗ X)
```

**Категорная интерпретация**: Это начальная алгебра для функтора F(X) = ⊤ ⊕ (A ⊗ X):
```
fold : ⊤ ⊕ (A ⊗ ?A) → ?A
```

Структура: индуктивный тип с конструкторами:
- `empty : ?A` через fold(inl(*))
- `cons : A ⊗ ?A → ?A` через fold(inr(−))

Элементы ?A — это конечные неупорядоченные мультимножества элементов A.

**Универсальное свойство** (катаморфизм): Для любой алгебры α : ⊤ ⊕ (A ⊗ C) → C существует единственный морфизм:
```
cata(α) : ?A → C
```
такой что:
```
⊤ ⊕ (A ⊗ ?A) --⊤⊕(A⊗cata(α))--> ⊤ ⊕ (A ⊗ C)
 | |
 fold α
 | |
 v v
 ?A ----------cata(α)--------> C
```

**Монадные операции**:

**Единица** η_A : A → ?A (одноэлементное мультимножество):
```
η_A(a) = fold(inr(a, fold(inl(*))))
```

**Умножение** μ_A : ??A → ?A (конкатенация мультимножеств):
```
μ_A = cata([empty, λ(xs, xss). append(xs, μ_A(xss))])
```
где `append : ?A ⊗ ?A → ?A` конкатенирует мультимножества.

**Сравнение с !**:
- **!A = Π&(n:ℕ). A^⊗n**: коиндуктивно, все арности одновременно
- **?A = μX. ⊤ ⊕ (A ⊗ X)**: индуктивно, конечное мультимножество

#### 6.2.2 Альтернативные построения

**Через индексированную сумму с факторизацией**:
```
?A := Σ⊕(n:ℕ). (A^⊗n / Sₙ)
```
где Sₙ — симметрическая группа. Явно выражает конечность и факторизацию по перестановкам (коммутативность).

**Через дуальность**:
```
?A := (!(A⊥))⊥
```
Определение через линейное отрицание, обеспечивающее корректную категорную дуальность.

### 11.1.3 Дуальность ! и ? — проблема и решение

#### 6.3.1 Проверка дуальности основных определений

Проверим, являются ли наши основные определения дуальными:

**Для !A = Π&(n:ℕ). (A^⊗n)**:
```
(!A)⊥ = (Π&(n:ℕ). A^⊗n)⊥
 ≅ Σ⊕(n:ℕ). (A^⊗n)⊥ [дуальность Π&/Σ⊕]
 ≅ Σ⊕(n:ℕ). ((A⊥)^⅋n) [де Морган: (A⊗B)⊥ = A⊥ ⅋ B⊥]
```

где (A⊥)^⅋n = A⊥ ⅋ A⊥ ⅋ ... ⅋ A⊥.

**Для ?A = μX. ⊤ ⊕ (A ⊗ X)**:
```
(?A)⊥ = (μX. ⊤ ⊕ (A ⊗ X))⊥
 ≅ νX. (⊤ ⊕ (A ⊗ X))⊥ [дуальность μ/ν]
 ≅ νX. (⊥ & (A⊥ ⅋ X)) [де Морган]
 ≅ νX. (A⊥ ⅋ X) [⊥ & B ≅ B]
```

**Проблема**: νX. (A⊥ ⅋ X) не совпадает с Π&(n:ℕ). (A⊥)^⊗n !

Наши определения **не полностью дуальны** в категорном смысле.

#### 6.3.2 Решение: согласованные дуальные определения

Есть несколько подходов к разрешению этой проблемы:

**Подход 1: Использовать коиндуктивное определение для !**

Если взять:
```
!A := νX. 1 ⊕ (A & X)
?A := μX. ⊤ ⊕ (A ⊗ X)
```

Тогда:
```
(?A)⊥ = (μX. ⊤ ⊕ (A ⊗ X))⊥
 ≅ νX. (⊥ & (A⊥ ⅋ X))
 ≅ νX. (A⊥ ⅋ X)
```

Это ближе к νX. 1 ⊕ (A⊥ & X), но требует изоморфизма между ⅋ и &, который не всегда существует.

**Подход 2: Признать частичную дуальность**

Комонада ! и монада ? **функционально дуальны** (через сопряжение ! ⊣ ?), но их конкретные представления через (ко)индуктивные типы **не являются прямыми категорными дуалами** через (−)⊥.

**Корректная формулировка**:
```
Hom(!A, B) ≅ Hom(A, ?B) (сопряжение)
(?A)⊥ ≅ !(A⊥) (не точный изоморфизм для наших определений)
```

**Подход 3: Использовать только одно семейство определений**

Для полной дуальности через (−)⊥, можно определить:
```
!A := Π&(n:ℕ). (A^⊗n)
?A := Σ⊕(n:ℕ). (A^⅋n) [используем ⅋ вместо ⊗!]
```

Тогда:
```
(!A)⊥ = (Π&(n:ℕ). A^⊗n)⊥
 ≅ Σ⊕(n:ℕ). (A⊥)^⅋n
 = ?(A⊥) 
```

#### 6.3.3 Фундаментальная проблема категорной дуальности

**Проблема с ⅋**: Попытка "исправить" дуальность через:
```
?A := Σ⊕(n:ℕ). (A^⅋n)
```
**не работает**, потому что из A ⅋ A мы не можем извлечь два независимых A! Par (⅋) описывает параллельную композицию контекстов, а не независимое множество элементов.

**Глубинная причина**: В MALL семантика связок:
- **⊗**: A ⊗ B даёт независимый доступ к A и B
- **⅋**: A ⅋ B требует выбора одного контекста (параллельная композиция, не независимость)
- **&**: A & B позволяет недетерминированный выбор одной проекции
- **⊕**: A ⊕ B требует детерминированного выбора одного варианта

Эти семантические различия делают точную категорную дуальность через (−)⊥ **невозможной** при сохранении корректной операционной семантики.

#### 6.3.4 Альтернативные подходы

**Структурная дуальность** (через (ко)индуктивность):
```
!A := νX. 1 ⊕ (A & X) [коиндуктивное]
?A := μX. ⊤ ⊕ (A ⊗ X) [индуктивное]
```

Преобразования дуальности: μ ↔ ν, ⊗ ↔ &, 1 ↔ ⊤, но ⊕ ↔ ⊕ (не меняется).

Это даёт структурную симметрию, но не точную категорную дуальность через (−)⊥.

#### 6.3.5 Вывод для нашей системы

В категории **Lin** с MALL и зависимыми типами мы имеем:

1. **Сопряжение ! ⊣ ?** — главное свойство, обеспечивающее функциональную дуальность
2. **Структурную симметрию** между индуктивностью/коиндуктивностью
3. **Точную категорную дуальность** через (−)⊥ невозможно реализовать

**Теоретическое замечание**: Это известная проблема в теории линейной логики. Экспоненциальные модальности ! и ? в *-автономной категории с MALL требуют дополнительной структуры (например, модальности должны формировать *-автономную подкатегорию), что выходит за рамки простого применения (−)⊥.

**Практическая позиция**: Сопряжение ! ⊣ ? полностью достаточно для:
- Корректной операционной семантики
- Всех вычислительных применений
- Доказательства свойств системы типов

Категорная дуальность через (−)⊥ — это дополнительное теоретическое свойство, которое в данной системе не реализуется.

#### 6.3.2 Сопряжение ! ⊣ ?

**Изоморфизм hom-множеств**:
```
Hom(!A, B) ≅ Hom(A, ?B)
```

**Явная конструкция (основанная на реальной семантике)**:

Для f : !A → B, определяем curry(f) : A → ?B:
```
curry(f)(a) = η_?B(f(η_!A(a)))
```
где η_!A(a) создаёт "минимальный" элемент !A, содержащий один a, а η_?B оборачивает результат в одноэлементное мультимножество.

Для g : A → ?B, определяем uncurry(g) : !A → B:
```
uncurry(g)(x) = ... (потребляет x по частям, применяя g и комбинируя результаты)
```

**Интуитивная интерпретация**:
- Морфизм f : !A → B может использовать любое количество копий A для производства одного B
- Морфизм g : A → ?B производит мультимножество (недетерминистический выбор) результатов B
- Эти две возможности дуальны: "потреблять много" ↔ "производить много"

**Единица и коединица сопряжения**:

Единица η : Id → ? ∘ ! :
```
η_A : A → ?(!A)
η_A(a) = unit(!a) где !a — "минимальный" элемент !A
```

Коединица ε : ! ∘ ? → Id :
```
ε_A : !(?A) → A
ε_A(x) = ... (извлекает один A из структуры мультимножеств)
```

### 11.1.4 Категорные свойства

#### 6.4.1 Комонада !

**Функтор**: ! : **Lin** → **Lin**

**Коумножение** δ : ! → ! ∘ ! (естественная трансформация):
```
δ_A : !A → !!A
```

**Коединица** ε : ! → Id:
```
ε_A : !A → A
```

**Аксиомы комонады**:
```
(! ∘ δ) · δ = (δ ∘ !) · δ (коассоциативность)
(! ∘ ε) · δ = id (левая коединичность)
(ε ∘ !) · δ = id (правая коединичность)
```

**Диаграммы**:
```
 δ !δ
!A ------> !!A ------> !!!A
 \ |
 \ | δ∘!
 \δ |
 \ v
 \--> !!A


 δ !ε
!A ------> !!A ------> !A
 \ | /
 \ | /
 \id |ε∘! /id
 \ | /
 \ v /
 \---- A ----/
```

#### 6.4.2 Монада ?

**Функтор**: ? : **Lin** → **Lin**

**Умножение** μ : ? ∘ ? → ? (естественная трансформация):
```
μ_A : ??A → ?A
```

**Единица** η : Id → ?:
```
η_A : A → ?A
```

**Аксиомы монады**:
```
μ · (μ ∘ ?) = μ · (? ∘ μ) (ассоциативность)
μ · (η ∘ ?) = id (левая единичность)
μ · (? ∘ η) = id (правая единичность)
```

#### 6.4.3 Алгебры и коалгебры

**Коалгебры Эйленберга-Мура для !**:

Коалгебра — это (C, γ : C → !C) такая что:
```
 γ !γ
C ---------> !C ---------> !!C
 \ | ^
 \ | /
 \γ |δ∘γ /
 \ | /
 \ v /
 \---> !C -------/
```

Категория **Cart** = **CoAlg(!)** — это категория картезианских типов (с дублированием и удалением).

**Алгебры Эйленберга-Мура для ?**:

Алгебра — это (C, α : ?C → C) такая что диаграммы монады коммутируют.

### 11.1.5 Связь с (ко)индуктивными типами

#### 6.5.1 ! как универсальная коиндукция

Для любого коиндуктивного типа νX.F(X), где F строится из MALL-связок:
```
!(νX.F(X)) ≅ νY. Π&(n:ℕ). F^n(Y)
```

Комонада ! "стабилизирует" коиндукцию, позволяя наблюдать произвольное количество разворачиваний.

#### 6.5.2 ? как универсальная индукция

Для любого индуктивного типа μX.F(X):
```
?(μX.F(X)) ≅ μY. Σ⊕(n:ℕ). F^n(Y)
```

Монада ? "стабилизирует" индукцию, позволяя выбирать глубину конструирования.

### 11.1.6 Вычислительная интерпретация

#### 6.6.1 ! и дублирование ресурсов

В вычислениях, !A означает:
- Значение типа A доступно в памяти
- Может быть прочитано произвольное количество раз
- Может быть проигнорировано (garbage collected)

**Пример**: В языках программирования это соответствует:
- Неизменяемым (immutable) значениям
- Значениям с reference counting или GC
- Copy-on-write структурам

#### 6.6.2 ? и недетерминизм

В вычислениях, ?A означает:
- Недетерминистический выбор значения типа A
- Возможность отложенного вычисления (lazy evaluation)
- Множественные ветви вычислений

### 11.1.7 Функториальные свойства

#### 11.1.7.1 ! как моноидальный функтор

**! сохраняет моноидальную структуру**:
```
!(A ⊗ B) ≅ !A ⊗ !B
!1 ≅ 1
```

**! не сохраняет аддитивную структуру**:
```
!(A ⊕ B) ≠ !A ⊕ !B (в общем случае)
!(A & B) ≅ !A & !B
```

#### 11.1.7.2 ? как функтор над аддитивной структурой

**? взаимодействует с ⊕**:
```
?(A ⊕ B) → ?A ⊕ ?B
```
(но не изоморфизм в общем случае — мультимножество может содержать элементы из обеих компонент)

**? не сохраняет &**:
```
?(A & B) ≠ ?A & ?B (в общем случае)
```

**? как функтор мультимножеств**:
```
map_? : (A → B) → (?A → ?B)
map_?(f)(xs) = rec_μ(xs, λt. match t with
 | inl(*) → empty
 | inr(a, xs') → cons(f(a), map_?(f)(xs')))
```

Это делает ? эндофунктором на **Lin**, но с более сложными функториальными свойствами чем !.


### 11.2 Другие модальности: расширения базовой системы

Помимо экспоненциальных модальностей ! и ?, структура категории **Lin** позволяет определить множество других модальностей для различных применений. Все эти модальности **не входят в базовую систему**, но могут быть добавлены как расширения, используя (ко)индуктивные типы и структуру MALL.

#### 11.2.1 Временные модальности

**Модальность "всегда в будущем" (□)**:
```
□A := νX. A & X
```
Коиндуктивный поток, где A истинно на каждом шаге времени в будущем.

**Модальность "когда-нибудь в будущем" (◇)**:
```
◇A := μX. A ⊕ X
```
Индуктивный тип: либо A истинно сейчас, либо будет истинно позже.

**Категорная интерпретация**: Образуют комонаду (□) и монаду (◇) на категории **Lin**.

**Сопряжение**: □ ⊣ ◇ в присутствии соответствующей временной структуры.

**С зависимыми типами — богаче**:
- **Индексированные временем**: □_t A := Π&(t':Time, t'≥t).A(t') — зависимость от момента времени
- **С длительностью**: □^d A := Π&(t:Time, t∈[now, now+d]).A(t) — истинно в течение интервала d
- **С метриками**: □_μ A := Π&(t:Time).A(t) ⊗ Metric(t) — с временными метриками
- **Зависимое until**: Σ⊗(t:Time).A(t) U_t B(t) — until с зависимостью от времени

#### 11.2.2 Пространственные модальности

**"Везде в пространстве" (□_S)**:
```
□_S A := Π&(l:Location).A(l)
```
Семейство, индексированное по пространственным локациям.

**"Где-то в пространстве" (◇_S)**:
```
◇_S A := Σ⊕(l:Location).A(l)
```
Экзистенциальный выбор локации.

**"Здесь" (at_l)**:
```
at_l : A → □_S A
at_l(a) = λloc. if loc = l then a else error
```

**С зависимыми типами — богаче**:
- **С метрикой расстояния**: □_r A := Π&(l:Location, d(l,here)≤r).A(l) — в радиусе r
- **С топологией**: □_U A := Π&(l:U).A(l) для открытого множества U
- **Региональные**: Σ⊗(r:Region).Π&(l:r).A(l) — по регионам с зависимостью
- **С ресурсами**: Σ⊗(l:Location).(A(l) ⊗ Resources(l)) — с локальными ресурсами

#### 11.2.3 Деонтические модальности (модальности долженствования)

**"Обязательно" (O)**:
```
O A := A & Obligation
```
где Obligation — специальный тип, представляющий обязательство.

**"Разрешено" (P)**:
```
P A := A ⊕ Permission
```
где Permission — тип разрешения.

**Категорная интерпретация**: O и P можно построить как:
```
O A := νX. A & (X ⊕ Violation)
P A := μX. A ⊕ (X & Grant)
```

Коиндуктивное "обязательство" — поток проверок соответствия, индуктивное "разрешение" — конечная цепь грантов.

**С зависимыми типами — богаче**:
- **С контекстом**: O_c A := Σ⊗(c:Context).(A(c) & Obligation(c)) — обязательство зависит от контекста
- **С приоритетами**: Π&(p:Priority).O_p A — обязательства разных уровней
- **С агентами**: Σ⊕(a:Agent).O_a A — кто обязан выполнить
- **Условные**: Π⅋(cond:Condition).O A — обязательство при условии

#### 11.2.4 Алетические модальности (модальности необходимости/возможности)

**"Необходимо" (□_N)**:
```
□_N A := Π&(w:World).A(w)
```
Истинно во всех возможных мирах.

**"Возможно" (◇_N)**:
```
◇_N A := Σ⊕(w:World).A(w)
```
Истинно в некотором возможном мире.

**Категорная интерпретация**: Это в точности Π& и Σ⊕ над типом возможных миров, что делает их естественными модальностями в системе с зависимыми типами.

**Связь с S4/S5**:
- Для рефлексивности: доступен текущий мир
- Для транзитивности: отношение доступности между мирами композируется
- Для симметрии (S5): отношение доступности симметрично

**С зависимыми типами — богаче**:
- **С отношением доступности**: Π&(w:World, R(w₀,w)).A(w) — через отношение R
- **Модальная глубина**: Σ⊗(n:ℕ).□ⁿ A — с указанием глубины вложенности
- **Контингентность**: Σ⊕(w:World).A(w) & Π&(w':World).¬A(w') — истинно где-то, но не везде
- **С вероятностью**: Π&(w:World).A(w) ⊗ Prob(w) — взвешенная необходимость

#### 11.2.5 Эпистемические модальности (модальности знания)

**"Агент знает" (K_a)**:
```
K_a A := Π&(s:State_a).A(s)
```
где State_a — множество состояний, которые агент a считает возможными.

**"Агент считает возможным" (M_a)**:
```
M_a A := Σ⊕(s:State_a).A(s)
```

**"Общее знание" (C)**:
```
C A := νX. A & (Π&(a:Agent).K_a X)
```
Коиндуктивное определение: A истинно и все агенты знают это, и все знают, что все знают, и т.д.

**С зависимыми типами — богаче**:
- **Знание о знании**: K_a(Σ⊗(b:Agent).K_b A) — a знает, что кто-то знает A
- **Распределённое знание**: Σ⊗(G:Group).D_G A := Π&(s:⋃_{a∈G} State_a).A(s) — объединение знаний группы
- **Временное знание**: K_a^t := Π&(s:State_a(t)).A(s) — знание в момент времени t
- **Условное знание**: Π⅋(e:Evidence).K_a A — знание при наличии свидетельств
- **С уверенностью**: Σ⊗(c:Confidence).K_a A ⊗ c — знание с уровнем уверенности

#### 11.2.6 Вероятностные модальности

**"С вероятностью p" (□_p)**:
```
□_p A := A ⊗ Prob(p)
```
где Prob(p) — тип вероятностных распределений.

Альтернативно, через стохастическую матрицу:
```
□_p A := Π&(s:Outcome).A(s) ⊗ ℝ_[0,1]
```
с ограничением Σ_s p_s = 1.

**Монада вероятностного выбора (D)**:
```
D A := Σ⊕(n:ℕ).(A^⊗n ⊗ Distribution(n))
```
Конечная смесь исходов с распределением.

**С зависимыми типами — богаче**:
- **Условная вероятность**: Σ⊗(e:Evidence).(A ⊗ Prob(A|e)) — вероятность при условии e
- **Байесовское обновление**: Π⅋(obs:Observation).□_p A → □_{p'} A — обновление с наблюдениями
- **Марковские процессы**: νX. Σ⊗(s:State).(A(s) ⊗ Prob(s) ⊗ X) — с зависимостью от состояния
- **Параметризованные распределения**: Σ⊗(θ:Parameters).D_θ A — семейство распределений

#### 11.2.7 Линейно-временная логика (LTL)

**"Until" (U)**:
```
A U B := μX. B ⊕ (A ⊗ X)
```
A истинно до тех пор, пока не станет истинно B.

**"Release" (R)**:
```
A R B := νX. B & (A ⅋ X)
```
B истинно до тех пор, пока не "освобождается" через A.

**С зависимыми типами — богаче**:
- **Bounded Until**: Σ⊗(n:ℕ).(A U_≤n B) — с ограничением на время
- **С предикатами**: Π⅋(P:Predicate).A U_P B — until с условием P на каждом шаге
- **Метрическое until**: Σ⊗(t:Time).A U_{[0,t]} B — с метрическим временным ограничением
- **Зависимое eventually**: Σ⊕(t:Time).◇_t A(t) — "когда-нибудь" с зависимостью от времени

#### 11.2.8 Афfinные и релевантные модальности

**Афfinная модальность (◯)**:
```
◯A := A ⊕ 1
```
Можно использовать A один раз или не использовать вообще.

**Релевантная модальность (◉)**:
```
◉A := μX. A ⊕ (A ⊗ X)
```
Можно использовать A один или более раз (но не ноль раз).

**С зависимыми типами — богаче**:
- **Условная афfinность**: Π⅋(cond:Condition).(A ⊕ 1(cond)) — можно не использовать при условии
- **Релевантность с учётом**: Σ⊗(n:ℕ_{>0}).A^⊗n — ровно n>0 использований
- **Весовая релевантность**: Σ⊗(uses:List(Weight)).⊗_{w∈uses} A — с весами использования
- **Контекстная афfinность**: Σ⊗(c:Context).(A(c) ⊕ 1) — зависит от контекста

#### 11.2.9 Градуированные модальности

**"Ровно n использований" (□_n)**:
```
□_n A := A^⊗n
```

**"До n использований" (□_≤n)**:
```
□_≤n A := Σ⊕(k:ℕ_{≤n}).A^⊗k
```

**"Минимум n использований" (□_≥n)**:
```
□_≥n A := A^⊗n ⊗ !A
```

**С зависимыми типами — богаче**:
- **Зависимая градация**: Σ⊗(n:ℕ).□_n(A(n)) — градация зависит от типа
- **Векторные градации**: Σ⊗(v:Vector(Resource)).A^⊗v — многомерные ресурсы
- **С ограничениями**: Π&(n:ℕ, P(n)).□_n A — градация с предикатом
- **Параметризованная**: Π⅋(params:Params).□_{f(params)} A — градация через функцию параметров
- **Интервальная**: Σ⊗(n:ℕ, m:ℕ, n≤m).□_{[n,m]} A := Σ⊕(k:ℕ, n≤k≤m).A^⊗k — диапазон использований

#### 11.2.10 Общая конструкция модальностей

**Теорема**: Любая модальность, которая может быть выражена через:
- (Ко)индуктивные типы (μ, ν)
- MALL-связки (⊗, ⅋, &, ⊕, 1, ⊥, ⊤, 0)
- Зависимые типы (Σ⊗, Π⅋, Π&, Σ⊕)

естественным образом определена в категории **Lin**.

**Универсальное свойство**: Для определения новой модальности M достаточно задать:
1. Функтор M : **Lin** → **Lin**
2. Либо монадную структуру (η : Id → M, μ : M ∘ M → M)
3. Либо комонадную структуру (ε : M → Id, δ : M → M ∘ M)
4. Либо общую эндофункторную структуру

**Роль зависимых типов**: Как показано выше, зависимые типы (Σ⊗, Π⅋, Π&, Σ⊕) значительно обогащают выразительность модальностей:
- **Индексирование**: Π& и Σ⊕ позволяют индексировать модальности (по времени, пространству, мирам, агентам)
- **Параметризация**: Σ⊗ позволяет модальностям зависеть от параметров
- **Условность**: Π⅋ позволяет вводить условные модальности
- **Композитность**: Комбинация зависимых связок даёт сложные модальные конструкции

Таким образом, система с четырьмя зависимыми связками естественно поддерживает богатое семейство модальностей без необходимости их встраивания в базовую систему.

### 11.3 Композиция и взаимодействие модальностей

**Композиция модальностей**:
```
(!□)A = !(□A) -- бесконечное использование временного потока
(□!)A = □(!A) -- временной поток бесконечно используемых значений
```

**Дистрибутивные законы**: Для корректной композиции модальностей M и N требуется дистрибутивный закон:
```
λ : M ∘ N → N ∘ M
```

**Примеры взаимодействия**:
- !□ : "можем запросить любое количество будущих значений"
- □! : "на каждом шаге времени значение может быть использовано произвольно"
- □_p ∘ ? : "вероятностное распределение над недетерминистическими выборами"

### 11.4 Резюме по модальностям

Структура категории **Lin**:
1. **Базовая система** (разделы 1-10) — MALL, зависимые типы, (ко)индукция, дифференцирование
2. **Модальности** (раздел 11) — расширения, определяемые через базовую структуру

**Преимущества такого подхода**:
- Модальности не "встроены", а "выводятся" из базовой структуры
- Единообразная техника определения различных модальностей
- Композиция модальностей через функториальную структуру
- Возможность добавления произвольных предметно-специфичных модальностей

**Примеры применений**:
- Темпоральная логика программ
- Пространственное рассуждение в распределённых системах
- Логика знаний для мультиагентных систем
- Вероятностное программирование
- Квантовые вычисления (линейность + модальности)

## 12. Резюме: ключевые структуры

### Базовая система (разделы 1-10)

Моноидальная категория **Lin** обладает следующей фундаментальной структурой:

### Моноидальные структуры:
1. **Симметричной моноидальной структурой** (⊗, 1) — мультипликативная
2. **Дуальной моноидальной структурой** (⅋, ⊥) с *-автономностью
3. **Биноидальной структурой** (&, ⊕) — аддитивная
4. **Моноидальной замкнутостью** (⊸) — линейная импликация

### Зависимые типы:
5. **Индексированной моноидальной структурой** для четырёх зависимых связок:
 - Σ⊗ — мультипликативная зависимая сумма (функтор из среза)
 - Π⅋ — мультипликативное зависимое произведение (дуальный функтор)
 - Π& — индексированное произведение (предел)
 - Σ⊕ — индексированная копроизведение (копредел)

### (Ко)индуктивные типы:
6. **Начальными алгебрами** (μ) — индуктивные типы с катаморфизмами
7. **Терминальными коалгебрами** (ν) — коиндуктивные типы с анаморфизмами
8. **Размерными типами** (μ^α, ν^α) — с явным контролем размера и ультрафинитизмом (∞ = 100500^100500)

### Дифференциальная структура:
9. **Дифференциальной структурой** (∂) с:
 - Правилом Лейбница для ⊗
 - Правилом цепочки для композиции
 - Универсальностью для всех типов благодаря финитности (размерные типы)
10. **Трассировой структурой** для компактных объектов с Tr(∂f) = ∂(Tr(f))

### Enrichment:
11. **Self-enrichment** — Hom(A,B) = A ⊸ B
12. **Структурой двойной категории** — горизонтальные морфизмы (обычные), вертикальные (дифференциалы)

### Семантика:
13. **Функториальной семантикой** в **Vect** (⟦∂A⟧ = T⟦A⟧) и **Rel**

---

### Расширения: модальности (раздел 11)

**Ключевое замечание**: Модальности **не являются частью базовой системы**. Они определяются как расширения, используя (ко)индуктивные типы и MALL-связки.

**Экспоненциальные модальности**:
- **! (of course)**: νX. 1 ⊕ (A & X) — комонада для повторного использования
- **? (why not)**: μX. ⊤ ⊕ (A ⊗ X) — монада для мультимножеств
- Сопряжение ! ⊣ ? обеспечивает функциональную дуальность

**Другие модальности** (примеры):
- Временные: □ (всегда), ◇ (когда-нибудь), U (until), R (release)
- Пространственные: □_S (везде), ◇_S (где-то)
- Деонтические: O (обязательно), P (разрешено)
- Алетические: □_N (необходимо), ◇_N (возможно)
- Эпистемические: K_a (знание), C (общее знание)
- Вероятностные: □_p, D (дистрибуция)
- Градуированные: □_n, □_≤n, □_≥n

**Универсальность**: Любая модальность, выразимая через (ко)индуктивные типы и MALL-связки, естественно определена в **Lin**.

---

### Общая архитектура

Эта структура обеспечивает полную категориальную семантику для системы типов с:
- **Линейностью** (управление ресурсами через MALL)
- **Зависимыми типами** (четыре связки для разных видов зависимостей)
- **(Ко)рекурсией** (начальные алгебры и терминальные коалгебры)
- **Дифференцированием** (zipper-структуры и инкрементальные вычисления)
- **Расширяемостью через модальности** (определяемые пользователем операторы)
